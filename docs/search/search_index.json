{
    "docs": [
        {
            "location": "/", 
            "text": "Overview\n\n\n\n\n\n\n\nRobot Specifications:\n\n\n\n\nConstrained radially to 13 cm\n\n\nConstrained to a maximum of 26 cm tall, double of radius\n\n\nWeighs less than 9 kg\n\n\nOperational for at least 2 hours\n\n\nBasic motion\n\n\nOmnidirectional (ability to move in any direction)\n\n\nAbility to avoid obstacles\n\n\nEquipped with various sensors for autonomous motion and path-planning capabilities\n\n\nEquipped with onboard computing capabilities\n\n\nRequired to be modular to accommodate future upgrades\n\n\nInclude an experimental mode where users can upload their own robot control algorithm for testing and learning", 
            "title": "Overview"
        }, 
        {
            "location": "/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/#robot-specifications", 
            "text": "Constrained radially to 13 cm  Constrained to a maximum of 26 cm tall, double of radius  Weighs less than 9 kg  Operational for at least 2 hours  Basic motion  Omnidirectional (ability to move in any direction)  Ability to avoid obstacles  Equipped with various sensors for autonomous motion and path-planning capabilities  Equipped with onboard computing capabilities  Required to be modular to accommodate future upgrades  Include an experimental mode where users can upload their own robot control algorithm for testing and learning", 
            "title": "Robot Specifications:"
        }, 
        {
            "location": "/gettingStarted/", 
            "text": "Getting Started\n\n\nBelow are instructions and suggestions for leveraging the OmniRobot ROS package.\n\n\nFor any issues, questions, suggestions, or failures, please contact us via the project slack channel.\n\n\nPrerequisites\n\n\nSoftware\n\n\n\n\nRobotic Operating System (ROS)\n - Basic understanding of ROS is necessary to work with this package.\n\n\nThreads/processes\n - Basic knowledge of tasks, threads, and processes is essential,\nbut not neccesary.\n\n\nUbuntu OS\n: ROS and Arduino can be utilized on Windows/Mac, but a Linux distro is preferred. The following instructions will assume you have Ubuntu 16.04 on your desktop/laptop and Ubuntu Mate on your Pi.\n\n\n\n\nHardware\n\n\nThe following materials will be necessary in assembling the OmniRobot:\n\n\n\n\nJumper cables\n\n\nPower supply for the Arduino\n\n\nPower Supply for the Pi\n\n\nJumper cables\n\n\nWifi Router\n\n\nComputer with SSH access\n\n\n\n\nInstalling\n\n\nInstalling Omnibot pkg on Pi\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\n\n\nDeploying ROSserial (Arduino) script\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\n\n\nRunning the Project\n\n\nRunning via ROSlaunch\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\n\n\nRunning Manually\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\n\n\nConfirm Successful Launch\n\n\nConfirm via RQT\n\n\nConfirm via ROStopic echo\n\n\nTesting via velocityPublisher Node\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\n\n1\n2\n3\ncatkin\n/\n\n    \nindex\n.\nmd\n  \n#\n \nThe\n \ndocumentation\n \nhomepage\n.\n\n    \n...\n       \n#\n \nOther\n \nmarkdown\n \npages\n,\n \nimages\n \nand\n \nother\n \nfiles\n.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/gettingStarted/#getting-started", 
            "text": "Below are instructions and suggestions for leveraging the OmniRobot ROS package.  For any issues, questions, suggestions, or failures, please contact us via the project slack channel.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/gettingStarted/#prerequisites", 
            "text": "", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/gettingStarted/#software", 
            "text": "Robotic Operating System (ROS)  - Basic understanding of ROS is necessary to work with this package.  Threads/processes  - Basic knowledge of tasks, threads, and processes is essential,\nbut not neccesary.  Ubuntu OS : ROS and Arduino can be utilized on Windows/Mac, but a Linux distro is preferred. The following instructions will assume you have Ubuntu 16.04 on your desktop/laptop and Ubuntu Mate on your Pi.", 
            "title": "Software"
        }, 
        {
            "location": "/gettingStarted/#hardware", 
            "text": "The following materials will be necessary in assembling the OmniRobot:   Jumper cables  Power supply for the Arduino  Power Supply for the Pi  Jumper cables  Wifi Router  Computer with SSH access", 
            "title": "Hardware"
        }, 
        {
            "location": "/gettingStarted/#installing", 
            "text": "", 
            "title": "Installing"
        }, 
        {
            "location": "/gettingStarted/#installing-omnibot-pkg-on-pi", 
            "text": "mkdocs new [dir-name]  - Create a new project.", 
            "title": "Installing Omnibot pkg on Pi"
        }, 
        {
            "location": "/gettingStarted/#deploying-rosserial-arduino-script", 
            "text": "mkdocs new [dir-name]  - Create a new project.", 
            "title": "Deploying ROSserial (Arduino) script"
        }, 
        {
            "location": "/gettingStarted/#running-the-project", 
            "text": "", 
            "title": "Running the Project"
        }, 
        {
            "location": "/gettingStarted/#running-via-roslaunch", 
            "text": "mkdocs new [dir-name]  - Create a new project.", 
            "title": "Running via ROSlaunch"
        }, 
        {
            "location": "/gettingStarted/#running-manually", 
            "text": "mkdocs new [dir-name]  - Create a new project.", 
            "title": "Running Manually"
        }, 
        {
            "location": "/gettingStarted/#confirm-successful-launch", 
            "text": "", 
            "title": "Confirm Successful Launch"
        }, 
        {
            "location": "/gettingStarted/#confirm-via-rqt", 
            "text": "", 
            "title": "Confirm via RQT"
        }, 
        {
            "location": "/gettingStarted/#confirm-via-rostopic-echo", 
            "text": "", 
            "title": "Confirm via ROStopic echo"
        }, 
        {
            "location": "/gettingStarted/#testing-via-velocitypublisher-node", 
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.", 
            "title": "Testing via velocityPublisher Node"
        }, 
        {
            "location": "/gettingStarted/#project-layout", 
            "text": "1\n2\n3 catkin / \n     index . md    #   The   documentation   homepage . \n     ...         #   Other   markdown   pages ,   images   and   other   files .", 
            "title": "Project layout"
        }, 
        {
            "location": "/systemArchitecture/", 
            "text": "System Architecture\n\n\nHardware\n\n\n\n\n\n\nDummy\n\n\n\n\nROS", 
            "title": "System Architecture"
        }, 
        {
            "location": "/systemArchitecture/#system-architecture", 
            "text": "", 
            "title": "System Architecture"
        }, 
        {
            "location": "/systemArchitecture/#hardware", 
            "text": "Dummy", 
            "title": "Hardware"
        }, 
        {
            "location": "/systemArchitecture/#ros", 
            "text": "", 
            "title": "ROS"
        }, 
        {
            "location": "/components/", 
            "text": "Components\n\n\nRaspberry Pi 3B\n\n\n\n\n\n\nWith its high memory and sampling frequency, this was the chosen microcontroller for sensor data collection and internetwork communication. The ultrasound sensor and accelerometer, and other sensors in the future, are attached to the GPIO pins onboard.\n\n\n\n\nArduino 101\n\n\n\n\n\n\nThe Arduino 101 is the chosen microcontroller for motor control and features an onboard accelerometer and gyroscope.\n\n\n\n\nAdafruit Motor Shield\n\n\n\n\n\n\nAll 3 stepper motors are connected to the Arduino through motor shields.\n\n\n\n\nHRLZ-MaxSonar-EZ\n\n\n\n\n\n\nThe HRLV-MaxSonar-EZ acts as\nthe distance sensor, which also acts\nas the obstacle avoidance sensor.\nWith a resolution of 1 mm and up to\n5 meter max range, it has the\nprecision and capabilities to find and\navoid obstacles as it is moving.\n\n\n\n\nNEMA-17 Stepper Motor\n\n\n\n\n\n\nThe 12V, 350 mA NEMA-17 Stepper Motors drive the omnidirectional wheels. These motors have two coils, both of which can be activated for maximum torque.\n\n\n\n\nOmnidirectional Wheel\n\n\n\n\n\n\nThe chosen 10.2 cm omnidirectional\nwheels are placed in 120\u00b0 angles from one\nanother. By placing the wheels at these\nangles, combined with each wheel\u2019s\nincorporated rollers along the edge of the\nwheels, the robot can move in all directions\nand not have impeding wheels affecting\nmotion.", 
            "title": "Components"
        }, 
        {
            "location": "/components/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/components/#raspberry-pi-3b", 
            "text": "With its high memory and sampling frequency, this was the chosen microcontroller for sensor data collection and internetwork communication. The ultrasound sensor and accelerometer, and other sensors in the future, are attached to the GPIO pins onboard.", 
            "title": "Raspberry Pi 3B"
        }, 
        {
            "location": "/components/#arduino-101", 
            "text": "The Arduino 101 is the chosen microcontroller for motor control and features an onboard accelerometer and gyroscope.", 
            "title": "Arduino 101"
        }, 
        {
            "location": "/components/#adafruit-motor-shield", 
            "text": "All 3 stepper motors are connected to the Arduino through motor shields.", 
            "title": "Adafruit Motor Shield"
        }, 
        {
            "location": "/components/#hrlz-maxsonar-ez", 
            "text": "The HRLV-MaxSonar-EZ acts as\nthe distance sensor, which also acts\nas the obstacle avoidance sensor.\nWith a resolution of 1 mm and up to\n5 meter max range, it has the\nprecision and capabilities to find and\navoid obstacles as it is moving.", 
            "title": "HRLZ-MaxSonar-EZ"
        }, 
        {
            "location": "/components/#nema-17-stepper-motor", 
            "text": "The 12V, 350 mA NEMA-17 Stepper Motors drive the omnidirectional wheels. These motors have two coils, both of which can be activated for maximum torque.", 
            "title": "NEMA-17 Stepper Motor"
        }, 
        {
            "location": "/components/#omnidirectional-wheel", 
            "text": "The chosen 10.2 cm omnidirectional\nwheels are placed in 120\u00b0 angles from one\nanother. By placing the wheels at these\nangles, combined with each wheel\u2019s\nincorporated rollers along the edge of the\nwheels, the robot can move in all directions\nand not have impeding wheels affecting\nmotion.", 
            "title": "Omnidirectional Wheel"
        }, 
        {
            "location": "/codeBase/", 
            "text": "Code Base\n\n\nLaunch Files\n\n\nOmnibot\n\n\n'launch/omnibot.launch'\n\n\nStarts up nodes for production. Robot listens for velocity updates.\n\n\n1\n2\n3\n4\n5\n6\nlaunch\n\n   \n!-- Start Ultrasound Node --\n\n  \nnode\n \nname=\nultrasoundPublisher_node\n \npkg=\nomnibot\n \ntype=\nultrasoundPublisher_node.py\n \n/\n\n   \n!-- Start ROSserial node --\n\n  \nnode\n \nname=\narduino_node\n \npkg=\nomnibot\n \ntype=\nstart_rosserial.sh\n \n/\n\n\n/launch\n\n\n\n\n\n\n\nOmnibot Dev\n\n\n'launch/omnibot_dev.launch'\n\n\nStarts up nodes for development and troubleshooting. Robot listens to incoming velocities from velocityPublisher node.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nlaunch\n\n  \n!--  Start velocityPublisher Node--\n\n  \nnode\n \nname=\nvelocityPublisher_node\n \npkg=\nomnibot\n \ntype=\nvelocityPublisher_node.py\n \n/\n\n  \n!--  Start Ultrasound Node --\n\n  \nnode\n \nname=\nultrasoundPublisher_node\n \npkg=\nomnibot\n \ntype=\nultrasoundPublisher_node.py\n \n/\n\n  \n!--  Start ROSserial Node--\n\n  \nnode\n \nname=\narduino_node\n \npkg=\nomnibot\n \ntype=\nstart_rosserial.sh\n \n/\n\n\n/launch\n\n\n\n\n\n\n\nScript Files\n\n\nUltrasound Node\n\n\n'scripts/ultrasoundPublisher_node.py'\n\n\nPublishes an integer value representing distance to target in millimeters\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n#!/usr/bin/python\n\n\nfrom\n \ntime\n \nimport\n \ntime\n\n\nfrom\n \nserial\n \nimport\n \nSerial\n \n# import library allowing python to interact with serial port\n\n\nimport\n \nrospy\n\n\nfrom\n \nstd_msgs.msg\n \nimport\n \nInt8\n \n# distance acquired will be fit into an 8bit variable\n\n\n\nserialDevice\n \n=\n \n/dev/ttyAMA0\n \n# default for RaspberryPi\n\n\nmaxwait\n \n=\n \n5\n \n# seconds to try for a good reading before quitting\n\n\n\n# Function was obtained from the Maxbotix website.\n\n\n# https://www.maxbotix.com/wp-content/uploads/2017/09/074_raspPi.txt\n\n\ndef\n \nget_measurement\n(\nportName\n):\n\n    \nser\n \n=\n \nSerial\n(\nportName\n,\n \n9600\n,\n \n8\n,\n \nN\n,\n \n1\n,\n \ntimeout\n=\n1\n)\n\n    \ntimeStart\n \n=\n \ntime\n()\n\n    \nvalueCount\n \n=\n \n0\n\n\n    \nwhile\n \ntime\n()\n \n \ntimeStart\n \n+\n \nmaxwait\n:\n\n        \nif\n \nser\n.\ninWaiting\n():\n\n            \nbytesToRead\n \n=\n \nser\n.\ninWaiting\n()\n\n            \nvalueCount\n \n+=\n \n1\n\n            \nif\n \nvalueCount\n \n \n2\n:\n \n# 1st reading may be partial number; throw it out\n\n                \ncontinue\n\n            \ntestData\n \n=\n \nser\n.\nread\n(\nbytesToRead\n)\n\n            \nif\n \nnot\n \ntestData\n.\nstartswith\n(\nb\nR\n):\n\n                \n# data received did not start with R\n\n                \ncontinue\n\n            \ntry\n:\n\n                \nsensorData\n \n=\n \ntestData\n.\ndecode\n(\nutf-8\n)\n.\nlstrip\n(\nR\n)\n\n            \nexcept\n \nUnicodeDecodeError\n:\n\n                \n# data received could not be decoded properly\n\n                \ncontinue\n\n            \ntry\n:\n\n                \nmm\n \n=\n \nint\n(\nsensorData\n)\n\n            \nexcept\n \nValueError\n:\n\n                \n# value is not a number\n\n                \ncontinue\n\n            \nser\n.\nclose\n()\n\n            \nreturn\n(\nmm\n)\n\n\n    \nser\n.\nclose\n()\n\n    \nraise\n \nRuntimeError\n(\nExpected serial data not received\n)\n\n\n\ndef\n \npublish_measurement\n(\nportName\n):\n\n    \n# Declare publisher\n\n    \n# Transmitting to =\n ultrasoundDistance_topic\n\n    \n# Using the \nInt8\n message type\n\n    \n# A maximnum of 10 messages will be held in the message queue.\n\n    \npub\n \n=\n \nrospy\n.\nPublisher\n(\nultrasoundDistance_topic\n,\n \nInt8\n,\n \nqueue_size\n=\n10\n)\n\n    \nrospy\n.\ninit_node\n(\nultrasoundPublisher_node\n)\n\n    \n# 10 readings will be published per second\n\n    \nrate\n \n=\n \nrospy\n.\nRate\n(\n10\n)\n \n# 10hz\n\n\n    \n# This keeps the node running until the script is shut down manually.\n\n    \n# node will keep cycling at the frequncy set above.\n\n    \nwhile\n \nnot\n \nrospy\n.\nis_shutdown\n():\n\n        \n# obtain measurement\n\n        \nmeasurement\n \n=\n \nget_measurement\n(\nportName\n)\n\n\n        \n# Log measurment to the terminal.\n\n        \nrospy\n.\nloginfo\n(\nmeasurement\n)\n\n        \n# publish measurmeent to the \nultrasoundDistance_topic\n.\n\n        \npub\n.\npublish\n(\nmeasurement\n)\n\n        \n# Causes ROS to pause, to ensure its cycleing at the frequency set above.\n\n        \nrate\n.\nsleep\n()\n\n\n\nif\n \n__name__\n \n==\n \n__main__\n:\n\n    \npublish_measurement\n(\nserialDevice\n)\n\n\n\n\n\n\n\nROSserial (Arduino)\n\n\nStart ROSserial Node\n\n\n'scripts/start_rosserial.bash'\n\n\nStarts up rosserial node (arduino). Run only after arduino is physically connected.\n\n\n1\n2\n#!/bin/bash\n\nrosrun rosserial_python serial_node.py _port:\n=\n/dev/ttyACM0\n\n\n\n\n\n\nMotors Only (No ROS)\n\n\n'scripts/arduino/basicMotor_noROS.ino'\n\n\nStarts up three step motors at 60 rpms each. ROS is not needed, as script starts up automatically with power source.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n#include \nWire.h\n\n\n#include \nAdafruit_MotorShield.h\n \n// library nbeeded to interact with motorshields\n\n\n\n// Declare motorshield objects at their locations\n\n\nAdafruit_MotorShield\n \nAFMStop\n(\n0x61\n);\n\n\nAdafruit_MotorShield\n \nAFMSbot\n(\n0x60\n);\n\n\n\n// Get motor handler objects from motorshield objects\n\n\n// Documentation on motors states 200 steps per rev\n\n\n// AFMStop.getStepper(200, 2) =\n AFMStop.getStepper(#OfSteps, motorShieldPort#)\n\n\nAdafruit_StepperMotor\n \n*\nstepMotor_1\n \n=\n \nAFMStop\n.\ngetStepper\n(\n200\n,\n \n2\n);\n\n\nAdafruit_StepperMotor\n \n*\nstepMotor_2\n \n=\n \nAFMSbot\n.\ngetStepper\n(\n200\n,\n \n1\n);\n\n\nAdafruit_StepperMotor\n \n*\nstepMotor_3\n \n=\n \nAFMSbot\n.\ngetStepper\n(\n200\n,\n \n2\n);\n\n\n\n// NOTE velocities are in rpm!!!!\n\n\nfloat\n \nstepMotor1_vel\n=\n \n60\n;\n\n\nfloat\n \nstepMotor2_vel\n=\n \n60\n;\n\n\nfloat\n \nstepMotor3_vel\n=\n \n60\n;\n\n\n\nvoid\n \nsetup\n()\n\n\n{\n  \n  \nAFMSbot\n.\nbegin\n();\n \n// Initialize the bottom shield\n\n  \nAFMStop\n.\nbegin\n();\n \n// Initialize the top shield\n\n\n  \nstepMotor_1\n-\nsetSpeed\n(\nstepMotor1_vel\n);\n \n// top \n\n  \nstepMotor_2\n-\nsetSpeed\n(\nstepMotor2_vel\n);\n \n// bot\n\n  \nstepMotor_3\n-\nsetSpeed\n(\nstepMotor3_vel\n);\n \n// bot\n\n\n}\n\n\n\nvoid\n \nloop\n()\n\n\n{\n\n  \n// NOTE =\n step(#OfSteps, direction, stepType)\n\n\n  \n// clockwise\n\n  \nstepMotor_1\n-\nstep\n(\n1\n,\n \nFORWARD\n,\n \nDOUBLE\n);\n\n  \n// counter-clockwise\n\n  \nstepMotor_2\n-\nstep\n(\n1\n,\n \nBACKWARD\n,\n \nDOUBLE\n);\n\n  \n// clockwise\n\n  \nstepMotor_3\n-\nstep\n(\n1\n,\n \nFORWARD\n,\n \nDOUBLE\n);\n\n\n}\n\n\n\n\n\n\n\nMotor Control Flow (w/ROS)\n\n\nBelow is a simplified version of teh arduino control loop and ROS cycle, when controlling the step motors.\n\n\n\nMotors Only (w/ ROS)\n\n\n'scripts/arduino/basicMotor_wROS.ino'\n\n\nStarts up three step motors at 0 rpms each. ROS is used to subscribe for velocity updates. Velocities are not actuaized until a power source is connected. Features 2 publsihers that transmit angular displacements and velocities of each motor.\n\n\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n#include \nWire.h\n\n\n#include \nAdafruit_MotorShield.h\n \n// library nbeeded to interact with motorshields\n\n\n#include \nros.h\n \n// library needed for ROS communication\n\n\n#include \nomnibot/MotorArray.h\n \n// library needed for custom ROS \nMotorArray\n msg type\n\n\n\nros\n::\nNodeHandle\n \nnh\n;\n \n// Instantiate ros handler object\n\n\n\n// Declare motorshield objects\n\n\n// This allows us to then interact with motors attached to our\n\n\n// motorshields.\n\n\nAdafruit_MotorShield\n \nAFMStop\n(\n0x61\n);\n\n\nAdafruit_MotorShield\n \nAFMSbot\n(\n0x60\n);\n\n\n\n// Initialize motor handler objects from the ports on the motorshields.\n\n\n// AFMStop.getStepper(200, 2) =\n motorShieldObject.getSTepper\n\n\nAdafruit_StepperMotor\n \n*\nstepMotor_1\n \n=\n \nAFMStop\n.\ngetStepper\n(\n200\n,\n \n2\n);\n\n\nAdafruit_StepperMotor\n \n*\nstepMotor_2\n \n=\n \nAFMSbot\n.\ngetStepper\n(\n200\n,\n \n1\n);\n\n\nAdafruit_StepperMotor\n \n*\nstepMotor_3\n \n=\n \nAFMSbot\n.\ngetStepper\n(\n200\n,\n \n2\n);\n\n\n\n// Declare array of step motors\n\n\n// Array is declared to 4 members, but we only index motors from 1-3\n\n\n// This was done for clarity of new users.\n\n\nAdafruit_StepperMotor\n*\n \nmotorArray\n[\n4\n];\n\n\n\n// Initialize motors at angular_vel=0; available globally\n\n\n// NOTE =\n Velocities are in RPMs !!\n\n\nfloat\n \nvelocityArray\n[\n4\n]\n \n=\n \n{\n0\n};\n \n\n\n// Step motors will vibrate regardless of what velocity is sent to the motor.\n\n\n// If motor velocity is \n0\n, the motor will still vibrate.\n\n\n// To avoid this, we define a thershold. if the desired velocity is below \n\n\n// this threshold, no step will be issued to the motor.\n\n\n// The motor velocity variables will still reflect this desired velosity, \n\n\n// even if it crosses the threshold.\n\n\nfloat\n \nvelocityThreshold\n \n=\n \n0.1\n;\n\n\n\n// Declare custom made variables that will hold our velocities and displacements,\n\n\n// that will be published to their respective topics.\n\n\nomnibot\n::\nMotorArray\n \ncurrentVelocities\n;\n\n\nomnibot\n::\nMotorArray\n \nangularDisplacements\n;\n \n// NOTE DISPLACEMNTS ARE IN RADIANS!!\n\n\n\n// Callback function for \nsetStepMotorVelocity_topic\n subscriber below. \n\n\n// Updates velocity variables from FIFO queue, but does not send a step \n\n\n// command to the motors.\n\n\n// The velocityArray is globally available. After this function updates \n\n\n// its values, the array is available for any other function to use.\n\n\n// The desired values are assign to the velocityArray, rgardless of \n\n\n// whether they are wihtin the threshold or not.\n\n\nvoid\n \nupdateMotorVelocities\n(\n \nconst\n \nomnibot\n::\nMotorArray\n \nvelocity_msg\n)\n\n\n{\n\n  \n// assign velocityArray values as recieved from \nsetStepMotorVelocity_topic\n \n\n  \nvelocityArray\n[\n1\n]\n \n=\n \nvelocity_msg\n.\nmotor1\n;\n \nvelocityArray\n[\n2\n]\n \n=\n \nvelocity_msg\n.\nmotor2\n;\n \nvelocityArray\n[\n3\n]\n \n=\n \nvelocity_msg\n.\nmotor3\n;\n\n\n  \n// The absolute value of the velocityArray values is sent to the motors.\n\n  \n// Negative values sent to the motors cause incorrect rotation.\n\n  \n// To actualize direction (CW and CCW), we use the \nBACKWARD\n/\nFORWARD\n parameters in the step command.\n\n  \nmotorArray\n[\n1\n]\n-\nsetSpeed\n(\nabs\n(\nvelocityArray\n[\n1\n]));\n\n  \nmotorArray\n[\n2\n]\n-\nsetSpeed\n(\nabs\n(\nvelocityArray\n[\n2\n]));\n\n  \nmotorArray\n[\n3\n]\n-\nsetSpeed\n(\nabs\n(\nvelocityArray\n[\n3\n]));\n\n\n}\n\n\n\n// Decides whether a desired velocity (absolute value of desired velocity) \n\n\n// is above (TRUE) the threshold, or below (FALSE).\n\n\nbool\n \nvelocityIsAboveThreshold\n(\nfloat\n \nmotorVel\n,\n \nfloat\n \nthreshold\n)\n\n\n{\n\n  \nif\n \n(\n \nabs\n(\nmotorVel\n)\n \n \nthreshold\n \n)\n \n{\n\n    \nreturn\n \ntrue\n;\n\n  \n}\n\n  \nreturn\n \nfalse\n;\n\n\n}\n\n\n\n// Grabs the values of the desired velocities, but takes the threshold \n\n\n// value nto consideration. If the value is above the threshold, \n\n\n// the velocity is returned. if value is below th ethreshold, a \n0\n is returned.\n\n\nfloat\n \ngetCurrentMotorVelocity\n(\nfloat\n \nvelocity\n,\n \nfloat\n \nthreshold\n)\n\n\n{\n \n  \nif\n \n(\nvelocityIsAboveThreshold\n(\nvelocity\n,\n \nthreshold\n))\n \n{\n\n    \nreturn\n \nvelocity\n;\n\n  \n}\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\n\n// Calculates the angular displacement, depending on the direction of rotation.\n\n\n// Our step motors are 200step motors. (Take 200 steps to rotate 360 degrees).\n\n\n// With each step being 1.8degrees and our velocities being relatively slow, w ecan\n\n\n// estimate our angular displacement per step as -1.8 || +1.8 dgerees.\n\n\n// Positive angular velocity (CCW) +1.8 == +0.0314159\n\n\n// Negative angular velocity (CW) -1.8 == -0.0314159\n\n\n// If velocity is zero (ie scenarios where vleocity is below threshold), a \n0\n is\n\n\n// returned for no angular displacement.\n\n\nfloat\n \ngetAngularDisplacement\n(\nfloat\n \nvelocity\n)\n\n\n{\n\n  \nif\n \n(\nvelocity\n \n \n0\n)\n \n{\n\n    \nreturn\n \n0.0314159\n;\n\n  \n}\n\n  \nelse\n \nif\n(\nvelocity\n \n \n0\n)\n \n{\n\n    \nreturn\n \n-\n0.0314159\n;\n\n  \n}\n\n  \nelse\n \n{\n\n    \nreturn\n \n0\n;\n\n  \n}\n \n\n}\n\n\n\n// Sends step command to the motors.\n\n\n// Takes threhsold into consideration. If desired velocity is \n0\n (ie like when below threshold),\n\n\n// then no step is issued. No need to send a step command if the velocity is zero.\n\n\n// This takes positive/negative signs into consideration. If desired velocity is\n\n\n// Positive angular velocity (CCW) == BACKWARD\n\n\n// Negative angular velocity (CW) == FORWARD\n\n\n// Step command is below:\n\n\n// motorArray[motorNumber]-\nstep(#OfSteps, DIRECTION, stepTYPE)\n\n\nvoid\n \nmotorStep\n(\nfloat\n \nmotorVel\n,\n \nint\n \nmotorNumber\n)\n\n\n{\n\n  \nif\n \n(\nvelocityIsAboveThreshold\n(\nmotorVel\n,\n \nvelocityThreshold\n))\n \n{\n\n    \nif\n(\nmotorVel\n \n \n0\n)\n \n{\n\n      \nmotorArray\n[\nmotorNumber\n]\n-\nstep\n(\n1\n,\n \nBACKWARD\n,\n \nDOUBLE\n);\n \n// clockwise\n\n    \n}\n\n    \nelse\n \n{\n\n      \nmotorArray\n[\nmotorNumber\n]\n-\nstep\n(\n1\n,\n \nFORWARD\n,\n \nDOUBLE\n);\n \n// counter-clockwise\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n// Initializes the publishers that report our current velocities and \n\n\n// angular displacmeents to the Pi.\n\n\nros\n::\nPublisher\n \ncurrentMotorVelocities_topic\n(\ncurrentMotorVelocities_topic\n,\n \ncurrentVelocities\n);\n\n\nros\n::\nPublisher\n \nangularDisplacements_topic\n(\nangularDisplacements_topic\n,\n \nangularDisplacements\n);\n\n\n\n// Assigns the velocities from our currently desired values to our\n\n\n// custom motorArray msg object.\n\n\nvoid\n \npublishCurrentMotorVelocities\n()\n\n\n{\n\n  \ncurrentVelocities\n.\nmotor1\n \n=\n \ngetCurrentMotorVelocity\n(\nvelocityArray\n[\n1\n],\n \nvelocityThreshold\n);\n\n  \ncurrentVelocities\n.\nmotor2\n \n=\n \ngetCurrentMotorVelocity\n(\nvelocityArray\n[\n2\n],\n \nvelocityThreshold\n);\n\n  \ncurrentVelocities\n.\nmotor3\n \n=\n \ngetCurrentMotorVelocity\n(\nvelocityArray\n[\n3\n],\n \nvelocityThreshold\n);\n\n\n  \ncurrentMotorVelocities_topic\n.\npublish\n(\n \ncurrentVelocities\n \n);\n\n\n}\n\n\n\n// Assigns the angular displacement (WRT our current iteration\ns velocity) toour\n\n\n// custom motorArray msg object.\n\n\nvoid\n \npublishAngularDisplacements\n()\n\n\n{\n \n  \nangularDisplacements\n.\nmotor1\n \n=\n \ngetAngularDisplacement\n(\ncurrentVelocities\n.\nmotor1\n);\n\n  \nangularDisplacements\n.\nmotor2\n \n=\n \ngetAngularDisplacement\n(\ncurrentVelocities\n.\nmotor2\n);\n\n  \nangularDisplacements\n.\nmotor3\n \n=\n \ngetAngularDisplacement\n(\ncurrentVelocities\n.\nmotor3\n);\n\n\n  \nangularDisplacements_topic\n.\npublish\n(\n \nangularDisplacements\n \n);\n\n\n}\n\n\n\n// Set up motorVelocities subscriber\n\n\n// The velocity for each stepMotor is declared inside of a custom motorArray ROS msg\n\n\n// and is recioeved through the \nsetStepMotorVelocity_topic\n.\n\n\nros\n::\nSubscriber\nomnibot\n::\nMotorArray\n \nmotorVelocities\n(\nsetStepMotorVelocity_topic\n,\n \nupdateMotorVelocities\n \n);\n\n\n\n// Iterates through the stepMotor array and performs the step command (if applicable).\n\n\nvoid\n \nactivateMotors\n()\n\n\n{\n\n  \nfor\n(\nint\n \ni\n \n=\n \n1\n;\n \ni\n \n \n4\n;\n \ni\n++\n)\n\n  \n{\n\n    \nmotorStep\n(\nvelocityArray\n[\ni\n],\n \ni\n);\n\n  \n}\n\n\n}\n\n\n\nvoid\n \nsetup\n()\n\n\n{\n\n  \nSerial\n.\nbegin\n(\n115200\n);\n \n// set baud rate\n\n  \nnh\n.\ninitNode\n();\n \n// Initialize ROSserial node\n\n\n  \n// notify master of our new publishers and subscribers\n\n  \nnh\n.\nsubscribe\n(\nmotorVelocities\n);\n\n  \nnh\n.\nadvertise\n(\ncurrentMotorVelocities_topic\n);\n\n  \nnh\n.\nadvertise\n(\nangularDisplacements_topic\n);\n\n\n  \nAFMSbot\n.\nbegin\n();\n \n// Initialize the bottom shield\n\n  \nAFMStop\n.\nbegin\n();\n \n// Initialize the top shield\n\n\n  \n// add motor instances to our motorArray\n\n  \n// ommited index=0 for clarity\n\n  \nmotorArray\n[\n1\n]\n \n=\n \nstepMotor_1\n;\n\n  \nmotorArray\n[\n2\n]\n \n=\n \nstepMotor_2\n;\n\n  \nmotorArray\n[\n3\n]\n \n=\n \nstepMotor_3\n;\n\n\n}\n\n\n\nvoid\n \nloop\n()\n\n\n{\n\n  \n// This causes ROS to cycle.\n\n  \n// Normally (on a multithreaded device) each subscriber\n\n  \n// works in its own thread. Because this device is \n\n  \n// single threaded, this function aids in protothreading and making\n\n  \n// sure our values are updated accordingly.\n\n  \nnh\n.\nspinOnce\n();\n\n\n  \n// Processes current desired velocities and sends the \n\n  \nactivateMotors\n();\n\n\n  \n// step commands ot the motors// Publishes currrent motor velocities to \ncurrentMotorVelocities_topic\n.\n\n  \npublishCurrentMotorVelocities\n();\n  \n  \n// Publishes the angular displacement for the current iteration to \nangularDisplacements_topic\n.\n\n  \npublishAngularDisplacements\n();\n\n\n}\n\n\n\n\n\n\n\nSensors Only (w/ ROS)\n\n\n'scripts/arduino/basicSensors_wROS.ino'\n\n\nBegins reading data from arudino's onboard accelerometer and gyroscope. ROS is used to publish linear acceleration, orientation, and angular velocity. External power source not needed (only USB). No subscribers.\n\n\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n#include \nros.h\n \n// ROS library\n\n\n#include \nCurieIMU.h\n \n// accelerometer library\n\n\n#include \nMadgwickAHRS.h\n \n// noise filter library\n\n\n#include \ngeometry_msgs/Vector3.h\n \n// ROS messages library\n\n\n\n// Instantiate ROS handler object.\n\n\n// (this makes it a ROS node)\n\n\nros\n::\nNodeHandle\n \nnh\n;\n \n\n\n// preallocate Vector3 variables to hold:\n\n\n// --------------------------------------\n\n\n// var orientation = orientation \n\n\n// var linearAccel = linear acceleration\n\n\n// var angularVel = angular velocity\n\n\ngeometry_msgs\n::\nVector3\n \norientation\n;\n \n\ngeometry_msgs\n::\nVector3\n \nlinearAccel\n;\n\n\ngeometry_msgs\n::\nVector3\n \nangularVel\n;\n\n\n\n// Set up publishers for each of the variables above.\n\n\n// Each of these publishers will publish each of the variables above,\n\n\n// every time the arduino loop executes (activated by the \nspinOnce\n on line 141).\n\n\nros\n::\nPublisher\n \norientation_topic\n(\norientation_topic\n,\n \norientation\n);\n\n\nros\n::\nPublisher\n \nlinearAccel_topic\n(\nlinearAccel_topic\n,\n \nlinearAccel\n);\n\n\nros\n::\nPublisher\n \nangularVel_topic\n(\nangularVel_topic\n,\n \nangularVel\n);\n\n\n\n// Create a Madgwick object to access the functions from the \n\n\n// Madgwick class in the library. Here, we call it filter.\n\n\n// A prewritten class from ADAFRUIT website that will allow \n\n\n// us to get a reading from the onboard gyroscope and accelerometer.\n\n\n// https://www.arduino.cc/en/Tutorial/Genuino101CurieIMUOrientationVisualiser\n\n\nMadgwick\n \nfilter\n;\n\n\n\n// initialize sensor data variables\n\n\nunsigned\n \nlong\n \nmicrosPerReading\n,\n \nmicrosPrevious\n;\n\n\nfloat\n \naccelScale\n,\n \ngyroScale\n;\n\n\n\n// The algorithm takes raw values from a gyroscope and accelerometer, \n\n\n// and uses them to return four quaternions:\n\n\n\nint\n \naix\n,\n \naiy\n,\n \naiz\n;\n\n\nint\n \ngix\n,\n \ngiy\n,\n \ngiz\n;\n\n\n\nfloat\n \nax\n,\n \nay\n,\n \naz\n;\n\n\nfloat\n \ngx\n,\n \ngy\n,\n \ngz\n;\n\n\n\n// which are 4-dimensional numbers which contain x, y, and z values to \n\n\n// represent the axis around which rotation occurs, as well as a \u03c9 value\n\n\n// which represents the value of rotation which occurs around the same \n\n\n// axis. These quaternions can be used to calculate the Euler angles \n\n\n// pitch, yaw, and roll.\n\n\n\nfloat\n \nroll\n,\n \npitch\n,\n \nheading\n;\n\n\nunsigned\n \nlong\n \nmicrosNow\n;\n\n\n\n// Helper functions for translating quarternion readings.\n\n\n// Both are used in \npublishLinearAccelAndangularVel()\n\n\nfloat\n \nconvertRawAcceleration\n(\nint\n \naRaw\n)\n \n{\n\n  \n// since we are using 2G range\n\n  \n// -2g maps to a raw value of -32768\n\n  \n// +2g maps to a raw value of 32767\n\n\n  \nfloat\n \na\n \n=\n \n(\naRaw\n \n*\n \n2.0\n)\n \n/\n \n32768.0\n;\n\n  \nreturn\n \na\n;\n\n\n}\n\n\nfloat\n \nconvertRawGyro\n(\nint\n \ngRaw\n)\n \n{\n\n  \n// since we are using 250 degrees/seconds range\n\n  \n// -250 maps to a raw value of -32768\n\n  \n// +250 maps to a raw value of 32767\n\n\n  \nfloat\n \ng\n \n=\n \n(\ngRaw\n \n*\n \n250.0\n)\n \n/\n \n32768.0\n;\n\n  \nreturn\n \ng\n;\n\n\n}\n\n\n\n// This function takes care of three different tasks\n\n\n// 1) Translatemrat raw quarternion readings to:\n\n\n//    -Gs for linear accelration (line )\n\n\n//    -Degrees/sec for angular velocity\n\n\n// 2) Publish tranlated motion values to their respective topics\n\n\n// 3) Update the the Madgwick object (the filter) to later obtain \n\n\n//    our roll, pitch, and yaw\n\n\nvoid\n \npublishLinearAccelAndangularVel\n()\n\n\n{\n\n  \n// convert from raw data to gravity and degrees/second units\n\n  \nax\n \n=\n \nconvertRawAcceleration\n(\naix\n);\n\n  \nay\n \n=\n \nconvertRawAcceleration\n(\naiy\n);\n\n  \naz\n \n=\n \nconvertRawAcceleration\n(\naiz\n);\n\n  \ngx\n \n=\n \nconvertRawGyro\n(\ngix\n);\n\n  \ngy\n \n=\n \nconvertRawGyro\n(\ngiy\n);\n\n  \ngz\n \n=\n \nconvertRawGyro\n(\ngiz\n);\n\n\n  \n// update the filter, which computes orientation\n\n  \n// we will call this filter in a separata function to get roll, pitch, yaw\n\n  \nfilter\n.\nupdateIMU\n(\ngx\n,\n \ngy\n,\n \ngz\n,\n \nax\n,\n \nay\n,\n \naz\n);\n\n\n  \n// attach linear accel and rotational vel values for publishing\n\n  \nlinearAccel\n.\nx\n \n=\n \nax\n;\n\n  \nlinearAccel\n.\ny\n \n=\n \nay\n;\n\n  \nlinearAccel\n.\nz\n \n=\n \naz\n;\n\n  \nangularVel\n.\nx\n \n=\n \ngx\n;\n\n  \nangularVel\n.\ny\n \n=\n \ngy\n;\n\n  \nangularVel\n.\nz\n \n=\n \ngz\n;\n\n\n  \n// publish values\n\n  \nlinearAccel_topic\n.\npublish\n(\n \nlinearAccel\n \n);\n\n  \nangularVel_topic\n.\npublish\n(\n \nangularVel\n \n);\n\n\n}\n\n\n\n// Retrieves roll, pitch, and yaw from the filter (Madgqiwck object)\n\n\n// and publishes it to the orientation topic.\n\n\n// Roll, pitch, and yaw are calculated according to the update performed on the filter \n\n\n// from \npublishLinearAccelAndangularVel()\n function (runs beforehand).\n\n\nvoid\n \npublishOrientation\n()\n\n\n{\n\n  \nroll\n \n=\n \nfilter\n.\ngetRoll\n();\n\n  \npitch\n \n=\n \nfilter\n.\ngetPitch\n();\n\n  \nheading\n \n=\n \nfilter\n.\ngetYaw\n();\n\n\n  \norientation\n.\nx\n \n=\n \nroll\n;\n\n  \norientation\n.\ny\n \n=\n \npitch\n;\n\n  \norientation\n.\nz\n \n=\n \nheading\n;\n\n\n  \norientation_topic\n.\npublish\n(\n \norientation\n \n);\n\n\n}\n\n\n\n// Checks to ensure its time to take a new reading, according to timestep defined\n\n\n// inside of the \nsetup()\n function.\n\n\n// If its time for a reading, linearAcceleration, angularVelocity,a nd orientation are\n\n\n// all read and published.\n\n\nvoid\n \nprocessAndPublishSensorData\n()\n\n\n{\n\n  \n// Timestep is calculated below.\n\n  \n// Configuration for the itme step is set in the \nsetup()\n function.\n\n  \nmicrosNow\n \n=\n \nmicros\n();\n\n  \nif\n \n(\nmicrosNow\n \n-\n \nmicrosPrevious\n \n=\n \nmicrosPerReading\n)\n \n{\n\n\n    \n// read raw data from CurieIMU and store in \naix, aiy, aiz, gix, giy, giz\n\n    \n// These variables are available globally!\n\n    \nCurieIMU\n.\nreadMotionSensor\n(\naix\n,\n \naiy\n,\n \naiz\n,\n \ngix\n,\n \ngiy\n,\n \ngiz\n);\n\n\n    \npublishLinearAccelAndangularVel\n();\n\n    \npublishOrientation\n();\n\n\n    \n// increment previous time, so we keep proper pace\n\n    \nmicrosPrevious\n \n=\n \nmicrosPrevious\n \n+\n \nmicrosPerReading\n;\n\n  \n}\n\n\n}\n\n\n\nvoid\n \nsetup\n()\n\n\n{\n\n  \n// Set baud rate for serial transmission.\n\n  \nSerial\n.\nbegin\n(\n115200\n);\n \n  \n// Initilizes the ROS node.\n\n  \nnh\n.\ninitNode\n();\n  \n\n  \n// Notify the master node that we have 3 publishers declared above.\n\n  \nnh\n.\nadvertise\n(\norientation_topic\n);\n\n  \nnh\n.\nadvertise\n(\nlinearAccel_topic\n);\n\n  \nnh\n.\nadvertise\n(\nangularVel_topic\n);\n\n\n  \n// Start the IMU and perform preliminary configuration by \n\n  \n// setting the sample rate of the acelerometer and the gyro \n\n  \n// and the filter to 25Hz:\n\n  \nCurieIMU\n.\nbegin\n();\n\n  \nCurieIMU\n.\nsetGyroRate\n(\n25\n);\n \n//25 Hz\n\n  \nCurieIMU\n.\nsetAccelerometerRate\n(\n25\n);\n \n// 25Hz\n\n  \nfilter\n.\nbegin\n(\n25\n);\n \n// 25Hz\n\n\n  \n// Set the accelerometer range to 2G\n\n  \nCurieIMU\n.\nsetAccelerometerRange\n(\n2\n);\n\n\n  \n// Set the gyroscope range to 250 degrees/second\n\n  \nCurieIMU\n.\nsetGyroRange\n(\n250\n);\n\n\n  \n// initialize variables to pace updates to correct rate\n\n  \nmicrosPerReading\n \n=\n \n1000000\n \n/\n \n25\n;\n\n  \nmicrosPrevious\n \n=\n \nmicros\n();\n\n\n}\n\n\n\nvoid\n \nloop\n()\n\n\n{\n\n  \n// This causes ROS to cycle.\n\n  \n// Normally (on a multithreaded device) each subscriber\n\n  \n// works in its own thread. Because this device is \n\n  \n// single threaded, this function aids in protothreading and making\n\n  \n// sure our values are updated accordingly.\n\n  \nnh\n.\nspinOnce\n();\n\n\n  \n// This line processes all other functions, preparing and publishing \n\n  \n// all outgoing data.\n\n  \nprocessAndPublishSensorData\n();\n\n\n}\n\n\n\n\n\n\n\nMotors + Sensors (w/ ROS)\n\n\n'scripts/arduino/motorsAndSensors_wROS.ino'\n\n\nStarts up three motors and onboard accelerometer/gyroscope.\nSubscribes to velocity updates.\nPublishes angular dispacmeents, motor velocities, orientation, linear acceleration, and angular velocity.\n\n\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n// =================================================\n\n\n// Motor Libraries [START] -------------------------\n\n\n#include \nWire.h\n\n\n#include \nAdafruit_MotorShield.h\n\n\n#include \nros.h\n\n\n#include \nstd_msgs/Int64.h\n\n\n#include \nstd_msgs/Float32MultiArray.h\n\n\n#include \ngeometry_msgs/Point.h\n\n\n#include \nomnibot/MotorArray.h\n\n\n// Motor Libraries [END] ---------------------------\n\n\n// =================================================\n\n\n// =================================================\n\n\n// Sensor Libraries [START] ------------------------\n\n\n#include \nCurieIMU.h\n\n\n#include \nMadgwickAHRS.h\n\n\n#include \ngeometry_msgs/Vector3.h\n\n\n// Sensor Libraries [END] --------------------------\n\n\n// =================================================\n\n\n\nros\n::\nNodeHandle\n \nnh\n;\n\n\n\n// ==============================================================\n\n\n// Motor variable declaration [START]----------------------------\n\n\nAdafruit_MotorShield\n \nAFMStop\n(\n0x61\n);\n\n\nAdafruit_MotorShield\n \nAFMSbot\n(\n0x60\n);\n\n\n\nAdafruit_StepperMotor\n \n*\nstepMotor_1\n \n=\n \nAFMStop\n.\ngetStepper\n(\n200\n,\n \n2\n);\n\n\nAdafruit_StepperMotor\n \n*\nstepMotor_2\n \n=\n \nAFMSbot\n.\ngetStepper\n(\n200\n,\n \n1\n);\n\n\nAdafruit_StepperMotor\n \n*\nstepMotor_3\n \n=\n \nAFMSbot\n.\ngetStepper\n(\n200\n,\n \n2\n);\n\n\n\nAdafruit_StepperMotor\n*\n \nmotorArray\n[\n4\n];\n\n\nfloat\n \nvelocityArray\n[\n4\n]\n \n=\n \n{\n0\n};\n \n// initialize motors at angular_vel=0; available globally\n\n\nfloat\n \nvelocityThreshold\n \n=\n \n0.1\n;\n\n\n\nomnibot\n::\nMotorArray\n \ncurrentVelocities\n;\n\n\nomnibot\n::\nMotorArray\n \nangularDisplacements\n;\n\n\n\nros\n::\nPublisher\n \ncurrentMotorVelocities_topic\n(\ncurrentMotorVelocities_topic\n,\n \ncurrentVelocities\n);\n\n\nros\n::\nPublisher\n \nangularDisplacements_topic\n(\nangularDisplacements_topic\n,\n \nangularDisplacements\n);\n\n\n// Motor variable declaration [END]------------------------------\n\n\n// ==============================================================\n\n\n\n// ==============================================================\n\n\n// Sensor variable declaration [START]----------------------------\n\n\ngeometry_msgs\n::\nVector3\n \norientation\n;\n\n\ngeometry_msgs\n::\nVector3\n \nlinearAccel\n;\n\n\ngeometry_msgs\n::\nVector3\n \nangularVel\n;\n\n\n\nros\n::\nPublisher\n \nlinearAccel_topic\n(\nlinearAccel_topic\n,\n \nlinearAccel\n);\n\n\nros\n::\nPublisher\n \nangularVel_topic\n(\nangularVel_topic\n,\n \nangularVel\n);\n\n\nros\n::\nPublisher\n \norientation_topic\n(\norientation_topic\n,\n \norientation\n);\n\n\n\nMadgwick\n \nfilter\n;\n\n\n\nunsigned\n \nlong\n \nmicrosPerReading\n,\n \nmicrosPrevious\n;\n\n\nfloat\n \naccelScale\n,\n \ngyroScale\n;\n\n\n\nint\n \naix\n,\n \naiy\n,\n \naiz\n;\n\n\nint\n \ngix\n,\n \ngiy\n,\n \ngiz\n;\n\n\n\nfloat\n \nax\n,\n \nay\n,\n \naz\n;\n\n\nfloat\n \ngx\n,\n \ngy\n,\n \ngz\n;\n\n\n\nfloat\n \nroll\n,\n \npitch\n,\n \nheading\n;\n\n\nunsigned\n \nlong\n \nmicrosNow\n;\n\n\n// Sensor variable declaration [END]------------------------------\n\n\n// ==============================================================\n\n\n\n// ==============================================================\n\n\n// Motor function and callbacks [START]--------------------------\n\n\n// callback function for subscriber below. Updates velocities from FIFO queue\n\n\nvoid\n \nupdateMotorVelocities\n(\n \nconst\n \nomnibot\n::\nMotorArray\n \nvelocity_msg\n)\n\n\n{\n\n  \nvelocityArray\n[\n1\n]\n \n=\n \nvelocity_msg\n.\nmotor1\n;\n \nvelocityArray\n[\n2\n]\n \n=\n \nvelocity_msg\n.\nmotor2\n;\n \nvelocityArray\n[\n3\n]\n \n=\n \nvelocity_msg\n.\nmotor3\n;\n\n\n  \nmotorArray\n[\n1\n]\n-\nsetSpeed\n(\nabs\n(\nvelocityArray\n[\n1\n]));\n\n  \nmotorArray\n[\n2\n]\n-\nsetSpeed\n(\nabs\n(\nvelocityArray\n[\n2\n]));\n\n  \nmotorArray\n[\n3\n]\n-\nsetSpeed\n(\nabs\n(\nvelocityArray\n[\n3\n]));\n\n\n}\n\n\n\nbool\n \nvelocityIsAboveThreshold\n(\nfloat\n \nmotorVel\n,\n \nfloat\n \nthreshold\n)\n\n\n{\n\n  \nif\n \n(\n \nabs\n(\nmotorVel\n)\n \n \nthreshold\n \n)\n \n{\n\n    \nreturn\n \ntrue\n;\n\n  \n}\n\n  \nreturn\n \nfalse\n;\n\n\n}\n\n\n\nfloat\n \ngetCurrentMotorVelocity\n(\nfloat\n \nvelocity\n,\n \nfloat\n \nthreshold\n)\n\n\n{\n\n\n  \nif\n \n(\nvelocityIsAboveThreshold\n(\nvelocity\n,\n \nthreshold\n))\n \n{\n\n    \nreturn\n \nvelocity\n;\n\n  \n}\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\n\nfloat\n \ngetAngularDisplacement\n(\nfloat\n \nvelocity\n)\n\n\n{\n\n  \nif\n \n(\nvelocity\n \n \n0\n)\n \n{\n\n    \nreturn\n \n0.0314159\n;\n\n  \n}\n\n  \nelse\n \nif\n(\nvelocity\n \n \n0\n)\n \n{\n\n    \nreturn\n \n-\n0.0314159\n;\n\n  \n}\n\n  \nelse\n \n{\n\n    \nreturn\n \n0\n;\n\n  \n}\n \n\n}\n\n\n\nvoid\n \nmotorStep\n(\nfloat\n \nmotorVel\n,\n \nint\n \nmotorNumber\n)\n\n\n{\n\n  \nif\n \n(\nvelocityIsAboveThreshold\n(\nmotorVel\n,\n \nvelocityThreshold\n))\n \n{\n\n    \nif\n(\nmotorVel\n \n \n0\n)\n \n{\n\n      \nmotorArray\n[\nmotorNumber\n]\n-\nstep\n(\n1\n,\n \nBACKWARD\n,\n \nDOUBLE\n);\n \n// clockwise\n\n    \n}\n\n    \nelse\n \n{\n\n      \nmotorArray\n[\nmotorNumber\n]\n-\nstep\n(\n1\n,\n \nFORWARD\n,\n \nDOUBLE\n);\n \n// counter-clockwise\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\nvoid\n \npublishCurrentMotorVelocities\n()\n\n\n{\n\n  \ncurrentVelocities\n.\nmotor1\n \n=\n \ngetCurrentMotorVelocity\n(\nvelocityArray\n[\n1\n],\n \nvelocityThreshold\n);\n\n  \ncurrentVelocities\n.\nmotor2\n \n=\n \ngetCurrentMotorVelocity\n(\nvelocityArray\n[\n2\n],\n \nvelocityThreshold\n);\n\n  \ncurrentVelocities\n.\nmotor3\n \n=\n \ngetCurrentMotorVelocity\n(\nvelocityArray\n[\n3\n],\n \nvelocityThreshold\n);\n\n\n  \ncurrentMotorVelocities_topic\n.\npublish\n(\n \ncurrentVelocities\n \n);\n\n\n}\n\n\n\nvoid\n \npublishAngularDisplacements\n()\n\n\n{\n \n  \nangularDisplacements\n.\nmotor1\n \n=\n \ngetAngularDisplacement\n(\ncurrentVelocities\n.\nmotor1\n);\n\n  \nangularDisplacements\n.\nmotor2\n \n=\n \ngetAngularDisplacement\n(\ncurrentVelocities\n.\nmotor2\n);\n\n  \nangularDisplacements\n.\nmotor3\n \n=\n \ngetAngularDisplacement\n(\ncurrentVelocities\n.\nmotor3\n);\n\n\n  \nangularDisplacements_topic\n.\npublish\n(\n \nangularDisplacements\n \n);\n\n\n}\n\n\n\n// Set up motorVelocities subscriber\n\n\nros\n::\nSubscriber\nomnibot\n::\nMotorArray\n \nmotorVelocities\n(\nsetStepMotorVelocity_topic\n,\n \nupdateMotorVelocities\n \n);\n\n\n\nvoid\n \nactivateMotors\n()\n\n\n{\n\n  \nfor\n(\nint\n \ni\n \n=\n \n1\n;\n \ni\n \n \n4\n;\n \ni\n++\n)\n\n  \n{\n\n    \nmotorStep\n(\nvelocityArray\n[\ni\n],\n \ni\n);\n\n  \n}\n\n\n}\n\n\n// Motor function and callbacks [END]----------------------------\n\n\n// ==============================================================\n\n\n\n// ==============================================================\n\n\n// Sensor function and callbacks [START]--------------------------\n\n\nfloat\n \nconvertRawAcceleration\n(\nint\n \naRaw\n)\n \n{\n\n  \n// since we are using 2G range\n\n  \n// -2g maps to a raw value of -32768\n\n  \n// +2g maps to a raw value of 32767\n\n\n  \nfloat\n \na\n \n=\n \n(\naRaw\n \n*\n \n2.0\n)\n \n/\n \n32768.0\n;\n\n  \nreturn\n \na\n;\n\n\n}\n\n\n\nfloat\n \nconvertRawGyro\n(\nint\n \ngRaw\n)\n \n{\n\n  \n// since we are using 250 degrees/seconds range\n\n  \n// -250 maps to a raw value of -32768\n\n  \n// +250 maps to a raw value of 32767\n\n\n  \nfloat\n \ng\n \n=\n \n(\ngRaw\n \n*\n \n250.0\n)\n \n/\n \n32768.0\n;\n\n  \nreturn\n \ng\n;\n\n\n}\n\n\n\nvoid\n \npublishLinearAndangularVel\n()\n\n\n{\n\n  \nax\n \n=\n \nconvertRawAcceleration\n(\naix\n);\n\n  \nay\n \n=\n \nconvertRawAcceleration\n(\naiy\n);\n\n  \naz\n \n=\n \nconvertRawAcceleration\n(\naiz\n);\n\n\n  \ngx\n \n=\n \nconvertRawGyro\n(\ngix\n);\n\n  \ngy\n \n=\n \nconvertRawGyro\n(\ngiy\n);\n\n  \ngz\n \n=\n \nconvertRawGyro\n(\ngiz\n);\n\n\n  \nfilter\n.\nupdateIMU\n(\ngx\n,\n \ngy\n,\n \ngz\n,\n \nax\n,\n \nay\n,\n \naz\n);\n\n\n  \nlinearAccel\n.\nx\n \n=\n \nax\n;\n\n  \nlinearAccel\n.\ny\n \n=\n \nay\n;\n\n  \nlinearAccel\n.\nz\n \n=\n \naz\n;\n\n\n  \nangularVel\n.\nx\n \n=\n \ngx\n;\n\n  \nangularVel\n.\ny\n \n=\n \ngy\n;\n\n  \nangularVel\n.\nz\n \n=\n \ngz\n;\n\n\n  \nlinearAccel_topic\n.\npublish\n(\n \nlinearAccel\n \n);\n\n  \nangularVel_topic\n.\npublish\n(\n \nangularVel\n \n);\n\n\n}\n\n\n\nvoid\n \npublishOrientation\n()\n\n\n{\n\n  \nroll\n \n=\n \nfilter\n.\ngetRoll\n();\n\n  \npitch\n \n=\n \nfilter\n.\ngetPitch\n();\n\n  \nheading\n \n=\n \nfilter\n.\ngetYaw\n();\n\n\n  \norientation\n.\nx\n \n=\n \nroll\n;\n\n  \norientation\n.\ny\n \n=\n \npitch\n;\n\n  \norientation\n.\nz\n \n=\n \nheading\n;\n\n\n  \norientation_topic\n.\npublish\n(\n \norientation\n \n);\n\n\n}\n\n\n\nvoid\n \nprocessAndPublishSensorData\n()\n\n\n{\n\n  \nmicrosNow\n \n=\n \nmicros\n();\n\n  \nif\n \n(\nmicrosNow\n \n-\n \nmicrosPrevious\n \n=\n \nmicrosPerReading\n)\n \n{\n\n\n    \n// read raw data from CurieIMU\n\n    \nCurieIMU\n.\nreadMotionSensor\n(\naix\n,\n \naiy\n,\n \naiz\n,\n \ngix\n,\n \ngiy\n,\n \ngiz\n);\n\n\n    \npublishLinearAndangularVel\n();\n\n    \npublishOrientation\n();\n\n\n    \n// increment previous time, so we keep proper pace\n\n    \nmicrosPrevious\n \n=\n \nmicrosPrevious\n \n+\n \nmicrosPerReading\n;\n\n  \n}\n\n\n}\n\n\n// Sensor function and callbacks [END]----------------------------\n\n\n// ==============================================================\n\n\n\nvoid\n \nsetup\n()\n\n\n{\n\n  \nSerial\n.\nbegin\n(\n115200\n);\n \n// set baud rate\n\n  \nnh\n.\ninitNode\n();\n\n\n  \n// =============================================\n\n  \n// Motor setup [START]--------------------------\n\n  \nnh\n.\nsubscribe\n(\nmotorVelocities\n);\n\n  \nnh\n.\nadvertise\n(\ncurrentMotorVelocities_topic\n);\n\n  \nnh\n.\nadvertise\n(\nangularDisplacements_topic\n);\n\n\n  \nAFMSbot\n.\nbegin\n();\n\n  \nAFMStop\n.\nbegin\n();\n\n\n  \nmotorArray\n[\n1\n]\n \n=\n \nstepMotor_1\n;\n\n  \nmotorArray\n[\n2\n]\n \n=\n \nstepMotor_2\n;\n\n  \nmotorArray\n[\n3\n]\n \n=\n \nstepMotor_3\n;\n\n  \n// Motor setup [END]--------------------------\n\n  \n// ===========================================\n\n\n  \n// =============================================\n\n  \n// Sensor setup [START]--------------------------\n\n  \nnh\n.\nadvertise\n(\norientation_topic\n);\n\n  \nnh\n.\nadvertise\n(\nlinearAccel_topic\n);\n\n  \nnh\n.\nadvertise\n(\nangularVel_topic\n);\n\n\n  \nCurieIMU\n.\nbegin\n();\n\n  \nCurieIMU\n.\nsetGyroRate\n(\n25\n);\n\n  \nCurieIMU\n.\nsetAccelerometerRate\n(\n25\n);\n\n  \nfilter\n.\nbegin\n(\n25\n);\n\n\n  \nCurieIMU\n.\nsetAccelerometerRange\n(\n2\n);\n\n  \nCurieIMU\n.\nsetGyroRange\n(\n250\n);\n\n\n  \nmicrosPerReading\n \n=\n \n1000000\n \n/\n \n25\n;\n\n  \nmicrosPrevious\n \n=\n \nmicros\n();\n\n  \n// Sensor setup [END]--------------------------\n\n  \n// ===========================================\n\n\n}\n\n\n\nvoid\n \nloop\n()\n\n\n{\n\n  \nnh\n.\nspinOnce\n();\n\n  \n// ====================================================\n\n  \n// Motor loop [START]----------------------------------\n\n  \nactivateMotors\n();\n\n  \npublishCurrentMotorVelocities\n();\n\n  \npublishAngularDisplacements\n();\n\n  \n// Motor loop [END]----------------------------------\n\n  \n// ====================================================\n\n  \n// ====================================================\n\n  \n// Sensor loop [START]----------------------------------\n\n  \nprocessAndPublishSensorData\n();\n\n  \n// Sensor loop [END]----------------------------------\n\n  \n// ====================================================\n\n\n}\n\n\n\n\n\n\n\nScript Files (Dev Only)\n\n\nVelocity Publisher Node\n\n\n'scripts/velocityPublisher_node.py'\n\n\nSets up motor velocities at 100 rpms each.\nBegins decreasing velocity at 1rpm per cycle (1 second)\nMotors will chnage direction, when velocities become negative.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n#!/usr/bin/env python\n\n\nimport\n \nrospy\n \n#import ROS pip package for using ROS library\n\n\nfrom\n \nomnibot.msg\n \nimport\n \nMotorArray\n \n# import our custom ROS msg types\n\n\n\ndef\n \nVelocityPublisher_talker\n():\n\n    \n# Declare publisher\n\n    \n# Transmitting to =\n setStepMotorVelocity_topic\n\n    \n# Using the \nMotorArray\n message type\n\n    \n# A maximnum of 10 messages will be held in the message queue.\n\n    \npub\n \n=\n \nrospy\n.\nPublisher\n(\nsetStepMotorVelocity_topic\n,\n \nMotorArray\n,\n \nqueue_size\n=\n10\n)\n\n\n    \n# Initialize node\n\n    \nrospy\n.\ninit_node\n(\nvelocityPublisher_node\n)\n\n\n    \n# Sets ROS to cycle at frequency of 1Hz\n\n    \nrate\n \n=\n \nrospy\n.\nRate\n(\n1\n)\n \n\n    \n# Set uinitial velocity to 100 rpms\n\n    \nvelocity\n=\n100.00\n\n\n    \n# This keeps the node running until the script is shut down manually.\n\n    \n# node will keep cycling at the frequncy set above.\n\n    \nwhile\n \nnot\n \nrospy\n.\nis_shutdown\n():\n \n        \n# Velocity decreases by 1 rpm every cycle\n\n        \nvelocity\n \n-=\n \n1.0\n\n        \n# Logs our MotorArray to the terminal\n\n        \nrospy\n.\nloginfo\n([\nvelocity\n,\nvelocity\n,\nvelocity\n])\n\n        \n# Publishes our motorArray to the \nsetStepMotorVelocity_topic\n\n        \npub\n.\npublish\n(\nvelocity\n,\nvelocity\n,\nvelocity\n)\n\n        \n# Causes the while loop to pause until its time to cycle again.\n\n        \n# How long it sleeps (pauses) depends on our declared frequnecy above.\n\n        \nrate\n.\nsleep\n()\n\n\n\nif\n \n__name__\n \n==\n \n__main__\n:\n\n    \ntry\n:\n\n        \nVelocityPublisher_talker\n()\n\n    \nexcept\n \nrospy\n.\nROSInterruptException\n:\n\n        \npass\n\n\n\n\n\n\n\nVelocity Publisher Node 1\n\n\n'scripts/velocityPublisher_node_1.py'\n\n\nStarts the motors at 30 rpm.\nCauses the motors to alternate directions every 5 seconds.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n#!/usr/bin/env python\n\n\nimport\n \ntime\n\n\nimport\n \nrospy\n\n\nfrom\n \nomnibot.msg\n \nimport\n \nMotorArray\n\n\n\n# Starts the motors at 30 rpm.\n\n\n# Causes the motors to alternate directions every 5 seconds.\n\n\n\ndef\n \nVelocityPublisher_talker\n():\n\n    \npub\n \n=\n \nrospy\n.\nPublisher\n(\nsetStepMotorVelocity_topic\n,\n \nMotorArray\n,\n \nqueue_size\n=\n10\n)\n\n    \nrospy\n.\ninit_node\n(\nvelocityPublisher_node\n)\n\n    \nrate\n \n=\n \nrospy\n.\nRate\n(\n1\n)\n\n    \nvelocity\n \n=\n \n30.00\n\n    \nwhile\n \nnot\n \nrospy\n.\nis_shutdown\n():\n\n        \nvelocity\n \n=\n \nvelocity\n \n*\n \n(\n-\n1\n)\n \n        \npub\n.\npublish\n(\nvelocity\n,\nvelocity\n,\nvelocity\n)\n\n        \ntime\n.\nsleep\n(\n5\n)\n\n\n\nif\n \n__name__\n \n==\n \n__main__\n:\n\n    \ntry\n:\n\n        \nVelocityPublisher_talker\n()\n\n    \nexcept\n \nrospy\n.\nROSInterruptException\n:\n\n        \npass\n\n\n\n\n\n\n\nVelocity Publisher Node 2\n\n\n'scripts/velocityPublisher_node_2.py'\n\n\nDisplays both directions for each motor in the following order.\nVelocities in either direction ar set to 30 rpm.\nScenarios alternate every 5 seconds.\n\n\nSet -\n 1\nMotor1 = CCW; Motor2 = CCW; Motor3= CCW\n\n\nSet -\n 2\nMotor1 = 0; Motor2 = 0; Motor3= 0\n\n\nSet -\n 3\nMotor1 = CW; Motor2 = CW; Motor3= CW\n\n\nSet -\n 4\nMotor1 = CCW; Motor2 = 0; Motor3= CW\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n#!/usr/bin/env python\n\n\nimport\n \ntime\n\n\nimport\n \nrospy\n\n\nfrom\n \nomnibot.msg\n \nimport\n \nMotorArray\n\n\n\n# Displays both directions for each motor in the following order.\n\n\n# Velocities in either direction ar set to 30 rpm.\n\n\n# Scenarios alternate every 5 seconds.\n\n\n\n# Set -\n 1\n\n\n# Motor1 = CCW; Motor2 = CCW; Motor3= CCW\n\n\n\n# Set -\n 2\n\n\n# Motor1 = 0; Motor2 = 0; Motor3= 0\n\n\n\n# Set -\n 3\n\n\n# Motor1 = CW; Motor2 = CW; Motor3= CW\n\n\n\n# Set -\n 4\n\n\n# Motor1 = CCW; Motor2 = 0; Motor3= CW\n\n\n\ndef\n \nVelocityPublisher_talker\n():\n\n    \npub\n \n=\n \nrospy\n.\nPublisher\n(\nsetStepMotorVelocity_topic\n,\n \nMotorArray\n,\n \nqueue_size\n=\n10\n)\n\n    \nrospy\n.\ninit_node\n(\nvelocityPublisher_node\n)\n\n    \nrate\n \n=\n \nrospy\n.\nRate\n(\n1\n)\n \n# 10hz\n\n    \npos_velocity\n \n=\n \n30.00\n\n    \nno_velocity\n \n=\n \n0\n\n    \nneg_velocity\n \n=\n \n-\n30.00\n\n    \nwhile\n \nnot\n \nrospy\n.\nis_shutdown\n():\n\n        \ntime\n.\nsleep\n(\n5\n)\n\n        \npub\n.\npublish\n(\npos_velocity\n,\npos_velocity\n,\npos_velocity\n)\n\n        \ntime\n.\nsleep\n(\n5\n)\n\n        \npub\n.\npublish\n(\nno_velocity\n,\nno_velocity\n,\nno_velocity\n)\n\n        \ntime\n.\nsleep\n(\n5\n)\n\n        \npub\n.\npublish\n(\nneg_velocity\n,\nneg_velocity\n,\nneg_velocity\n)\n\n        \ntime\n.\nsleep\n(\n5\n)\n\n        \npub\n.\npublish\n(\npos_velocity\n,\nno_velocity\n,\nneg_velocity\n)\n\n\n\nif\n \n__name__\n \n==\n \n__main__\n:\n\n    \ntry\n:\n\n        \nVelocityPublisher_talker\n()\n\n    \nexcept\n \nrospy\n.\nROSInterruptException\n:\n\n        \npass", 
            "title": "Code Base"
        }, 
        {
            "location": "/codeBase/#code-base", 
            "text": "", 
            "title": "Code Base"
        }, 
        {
            "location": "/codeBase/#launch-files", 
            "text": "", 
            "title": "Launch Files"
        }, 
        {
            "location": "/codeBase/#omnibot", 
            "text": "'launch/omnibot.launch'  Starts up nodes for production. Robot listens for velocity updates.  1\n2\n3\n4\n5\n6 launch \n    !-- Start Ultrasound Node -- \n   node   name= ultrasoundPublisher_node   pkg= omnibot   type= ultrasoundPublisher_node.py   / \n    !-- Start ROSserial node -- \n   node   name= arduino_node   pkg= omnibot   type= start_rosserial.sh   /  /launch", 
            "title": "Omnibot"
        }, 
        {
            "location": "/codeBase/#omnibot-dev", 
            "text": "'launch/omnibot_dev.launch'  Starts up nodes for development and troubleshooting. Robot listens to incoming velocities from velocityPublisher node.  1\n2\n3\n4\n5\n6\n7\n8 launch \n   !--  Start velocityPublisher Node-- \n   node   name= velocityPublisher_node   pkg= omnibot   type= velocityPublisher_node.py   / \n   !--  Start Ultrasound Node -- \n   node   name= ultrasoundPublisher_node   pkg= omnibot   type= ultrasoundPublisher_node.py   / \n   !--  Start ROSserial Node-- \n   node   name= arduino_node   pkg= omnibot   type= start_rosserial.sh   /  /launch", 
            "title": "Omnibot Dev"
        }, 
        {
            "location": "/codeBase/#script-files", 
            "text": "", 
            "title": "Script Files"
        }, 
        {
            "location": "/codeBase/#ultrasound-node", 
            "text": "'scripts/ultrasoundPublisher_node.py'  Publishes an integer value representing distance to target in millimeters   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67 #!/usr/bin/python  from   time   import   time  from   serial   import   Serial   # import library allowing python to interact with serial port  import   rospy  from   std_msgs.msg   import   Int8   # distance acquired will be fit into an 8bit variable  serialDevice   =   /dev/ttyAMA0   # default for RaspberryPi  maxwait   =   5   # seconds to try for a good reading before quitting  # Function was obtained from the Maxbotix website.  # https://www.maxbotix.com/wp-content/uploads/2017/09/074_raspPi.txt  def   get_measurement ( portName ): \n     ser   =   Serial ( portName ,   9600 ,   8 ,   N ,   1 ,   timeout = 1 ) \n     timeStart   =   time () \n     valueCount   =   0 \n\n     while   time ()     timeStart   +   maxwait : \n         if   ser . inWaiting (): \n             bytesToRead   =   ser . inWaiting () \n             valueCount   +=   1 \n             if   valueCount     2 :   # 1st reading may be partial number; throw it out \n                 continue \n             testData   =   ser . read ( bytesToRead ) \n             if   not   testData . startswith ( b R ): \n                 # data received did not start with R \n                 continue \n             try : \n                 sensorData   =   testData . decode ( utf-8 ) . lstrip ( R ) \n             except   UnicodeDecodeError : \n                 # data received could not be decoded properly \n                 continue \n             try : \n                 mm   =   int ( sensorData ) \n             except   ValueError : \n                 # value is not a number \n                 continue \n             ser . close () \n             return ( mm ) \n\n     ser . close () \n     raise   RuntimeError ( Expected serial data not received )  def   publish_measurement ( portName ): \n     # Declare publisher \n     # Transmitting to =  ultrasoundDistance_topic \n     # Using the  Int8  message type \n     # A maximnum of 10 messages will be held in the message queue. \n     pub   =   rospy . Publisher ( ultrasoundDistance_topic ,   Int8 ,   queue_size = 10 ) \n     rospy . init_node ( ultrasoundPublisher_node ) \n     # 10 readings will be published per second \n     rate   =   rospy . Rate ( 10 )   # 10hz \n\n     # This keeps the node running until the script is shut down manually. \n     # node will keep cycling at the frequncy set above. \n     while   not   rospy . is_shutdown (): \n         # obtain measurement \n         measurement   =   get_measurement ( portName ) \n\n         # Log measurment to the terminal. \n         rospy . loginfo ( measurement ) \n         # publish measurmeent to the  ultrasoundDistance_topic . \n         pub . publish ( measurement ) \n         # Causes ROS to pause, to ensure its cycleing at the frequency set above. \n         rate . sleep ()  if   __name__   ==   __main__ : \n     publish_measurement ( serialDevice )", 
            "title": "Ultrasound Node"
        }, 
        {
            "location": "/codeBase/#rosserial-arduino", 
            "text": "", 
            "title": "ROSserial (Arduino)"
        }, 
        {
            "location": "/codeBase/#start-rosserial-node", 
            "text": "'scripts/start_rosserial.bash'  Starts up rosserial node (arduino). Run only after arduino is physically connected.  1\n2 #!/bin/bash \nrosrun rosserial_python serial_node.py _port: = /dev/ttyACM0", 
            "title": "Start ROSserial Node"
        }, 
        {
            "location": "/codeBase/#motors-only-no-ros", 
            "text": "'scripts/arduino/basicMotor_noROS.ino'  Starts up three step motors at 60 rpms each. ROS is not needed, as script starts up automatically with power source.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40 #include  Wire.h  #include  Adafruit_MotorShield.h   // library nbeeded to interact with motorshields  // Declare motorshield objects at their locations  Adafruit_MotorShield   AFMStop ( 0x61 );  Adafruit_MotorShield   AFMSbot ( 0x60 );  // Get motor handler objects from motorshield objects  // Documentation on motors states 200 steps per rev  // AFMStop.getStepper(200, 2) =  AFMStop.getStepper(#OfSteps, motorShieldPort#)  Adafruit_StepperMotor   * stepMotor_1   =   AFMStop . getStepper ( 200 ,   2 );  Adafruit_StepperMotor   * stepMotor_2   =   AFMSbot . getStepper ( 200 ,   1 );  Adafruit_StepperMotor   * stepMotor_3   =   AFMSbot . getStepper ( 200 ,   2 );  // NOTE velocities are in rpm!!!!  float   stepMotor1_vel =   60 ;  float   stepMotor2_vel =   60 ;  float   stepMotor3_vel =   60 ;  void   setup ()  {   \n   AFMSbot . begin ();   // Initialize the bottom shield \n   AFMStop . begin ();   // Initialize the top shield \n\n   stepMotor_1 - setSpeed ( stepMotor1_vel );   // top  \n   stepMotor_2 - setSpeed ( stepMotor2_vel );   // bot \n   stepMotor_3 - setSpeed ( stepMotor3_vel );   // bot  }  void   loop ()  { \n   // NOTE =  step(#OfSteps, direction, stepType) \n\n   // clockwise \n   stepMotor_1 - step ( 1 ,   FORWARD ,   DOUBLE ); \n   // counter-clockwise \n   stepMotor_2 - step ( 1 ,   BACKWARD ,   DOUBLE ); \n   // clockwise \n   stepMotor_3 - step ( 1 ,   FORWARD ,   DOUBLE );  }", 
            "title": "Motors Only (No ROS)"
        }, 
        {
            "location": "/codeBase/#motor-control-flow-wros", 
            "text": "Below is a simplified version of teh arduino control loop and ROS cycle, when controlling the step motors.", 
            "title": "Motor Control Flow (w/ROS)"
        }, 
        {
            "location": "/codeBase/#motors-only-w-ros", 
            "text": "'scripts/arduino/basicMotor_wROS.ino'  Starts up three step motors at 0 rpms each. ROS is used to subscribe for velocity updates. Velocities are not actuaized until a power source is connected. Features 2 publsihers that transmit angular displacements and velocities of each motor.    1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201 #include  Wire.h  #include  Adafruit_MotorShield.h   // library nbeeded to interact with motorshields  #include  ros.h   // library needed for ROS communication  #include  omnibot/MotorArray.h   // library needed for custom ROS  MotorArray  msg type  ros :: NodeHandle   nh ;   // Instantiate ros handler object  // Declare motorshield objects  // This allows us to then interact with motors attached to our  // motorshields.  Adafruit_MotorShield   AFMStop ( 0x61 );  Adafruit_MotorShield   AFMSbot ( 0x60 );  // Initialize motor handler objects from the ports on the motorshields.  // AFMStop.getStepper(200, 2) =  motorShieldObject.getSTepper  Adafruit_StepperMotor   * stepMotor_1   =   AFMStop . getStepper ( 200 ,   2 );  Adafruit_StepperMotor   * stepMotor_2   =   AFMSbot . getStepper ( 200 ,   1 );  Adafruit_StepperMotor   * stepMotor_3   =   AFMSbot . getStepper ( 200 ,   2 );  // Declare array of step motors  // Array is declared to 4 members, but we only index motors from 1-3  // This was done for clarity of new users.  Adafruit_StepperMotor *   motorArray [ 4 ];  // Initialize motors at angular_vel=0; available globally  // NOTE =  Velocities are in RPMs !!  float   velocityArray [ 4 ]   =   { 0 };   // Step motors will vibrate regardless of what velocity is sent to the motor.  // If motor velocity is  0 , the motor will still vibrate.  // To avoid this, we define a thershold. if the desired velocity is below   // this threshold, no step will be issued to the motor.  // The motor velocity variables will still reflect this desired velosity,   // even if it crosses the threshold.  float   velocityThreshold   =   0.1 ;  // Declare custom made variables that will hold our velocities and displacements,  // that will be published to their respective topics.  omnibot :: MotorArray   currentVelocities ;  omnibot :: MotorArray   angularDisplacements ;   // NOTE DISPLACEMNTS ARE IN RADIANS!!  // Callback function for  setStepMotorVelocity_topic  subscriber below.   // Updates velocity variables from FIFO queue, but does not send a step   // command to the motors.  // The velocityArray is globally available. After this function updates   // its values, the array is available for any other function to use.  // The desired values are assign to the velocityArray, rgardless of   // whether they are wihtin the threshold or not.  void   updateMotorVelocities (   const   omnibot :: MotorArray   velocity_msg )  { \n   // assign velocityArray values as recieved from  setStepMotorVelocity_topic   \n   velocityArray [ 1 ]   =   velocity_msg . motor1 ;   velocityArray [ 2 ]   =   velocity_msg . motor2 ;   velocityArray [ 3 ]   =   velocity_msg . motor3 ; \n\n   // The absolute value of the velocityArray values is sent to the motors. \n   // Negative values sent to the motors cause incorrect rotation. \n   // To actualize direction (CW and CCW), we use the  BACKWARD / FORWARD  parameters in the step command. \n   motorArray [ 1 ] - setSpeed ( abs ( velocityArray [ 1 ])); \n   motorArray [ 2 ] - setSpeed ( abs ( velocityArray [ 2 ])); \n   motorArray [ 3 ] - setSpeed ( abs ( velocityArray [ 3 ]));  }  // Decides whether a desired velocity (absolute value of desired velocity)   // is above (TRUE) the threshold, or below (FALSE).  bool   velocityIsAboveThreshold ( float   motorVel ,   float   threshold )  { \n   if   (   abs ( motorVel )     threshold   )   { \n     return   true ; \n   } \n   return   false ;  }  // Grabs the values of the desired velocities, but takes the threshold   // value nto consideration. If the value is above the threshold,   // the velocity is returned. if value is below th ethreshold, a  0  is returned.  float   getCurrentMotorVelocity ( float   velocity ,   float   threshold )  {  \n   if   ( velocityIsAboveThreshold ( velocity ,   threshold ))   { \n     return   velocity ; \n   } \n   return   0 ;  }  // Calculates the angular displacement, depending on the direction of rotation.  // Our step motors are 200step motors. (Take 200 steps to rotate 360 degrees).  // With each step being 1.8degrees and our velocities being relatively slow, w ecan  // estimate our angular displacement per step as -1.8 || +1.8 dgerees.  // Positive angular velocity (CCW) +1.8 == +0.0314159  // Negative angular velocity (CW) -1.8 == -0.0314159  // If velocity is zero (ie scenarios where vleocity is below threshold), a  0  is  // returned for no angular displacement.  float   getAngularDisplacement ( float   velocity )  { \n   if   ( velocity     0 )   { \n     return   0.0314159 ; \n   } \n   else   if ( velocity     0 )   { \n     return   - 0.0314159 ; \n   } \n   else   { \n     return   0 ; \n   }   }  // Sends step command to the motors.  // Takes threhsold into consideration. If desired velocity is  0  (ie like when below threshold),  // then no step is issued. No need to send a step command if the velocity is zero.  // This takes positive/negative signs into consideration. If desired velocity is  // Positive angular velocity (CCW) == BACKWARD  // Negative angular velocity (CW) == FORWARD  // Step command is below:  // motorArray[motorNumber]- step(#OfSteps, DIRECTION, stepTYPE)  void   motorStep ( float   motorVel ,   int   motorNumber )  { \n   if   ( velocityIsAboveThreshold ( motorVel ,   velocityThreshold ))   { \n     if ( motorVel     0 )   { \n       motorArray [ motorNumber ] - step ( 1 ,   BACKWARD ,   DOUBLE );   // clockwise \n     } \n     else   { \n       motorArray [ motorNumber ] - step ( 1 ,   FORWARD ,   DOUBLE );   // counter-clockwise \n     } \n   }  }  // Initializes the publishers that report our current velocities and   // angular displacmeents to the Pi.  ros :: Publisher   currentMotorVelocities_topic ( currentMotorVelocities_topic ,   currentVelocities );  ros :: Publisher   angularDisplacements_topic ( angularDisplacements_topic ,   angularDisplacements );  // Assigns the velocities from our currently desired values to our  // custom motorArray msg object.  void   publishCurrentMotorVelocities ()  { \n   currentVelocities . motor1   =   getCurrentMotorVelocity ( velocityArray [ 1 ],   velocityThreshold ); \n   currentVelocities . motor2   =   getCurrentMotorVelocity ( velocityArray [ 2 ],   velocityThreshold ); \n   currentVelocities . motor3   =   getCurrentMotorVelocity ( velocityArray [ 3 ],   velocityThreshold ); \n\n   currentMotorVelocities_topic . publish (   currentVelocities   );  }  // Assigns the angular displacement (WRT our current iteration s velocity) toour  // custom motorArray msg object.  void   publishAngularDisplacements ()  {  \n   angularDisplacements . motor1   =   getAngularDisplacement ( currentVelocities . motor1 ); \n   angularDisplacements . motor2   =   getAngularDisplacement ( currentVelocities . motor2 ); \n   angularDisplacements . motor3   =   getAngularDisplacement ( currentVelocities . motor3 ); \n\n   angularDisplacements_topic . publish (   angularDisplacements   );  }  // Set up motorVelocities subscriber  // The velocity for each stepMotor is declared inside of a custom motorArray ROS msg  // and is recioeved through the  setStepMotorVelocity_topic .  ros :: Subscriber omnibot :: MotorArray   motorVelocities ( setStepMotorVelocity_topic ,   updateMotorVelocities   );  // Iterates through the stepMotor array and performs the step command (if applicable).  void   activateMotors ()  { \n   for ( int   i   =   1 ;   i     4 ;   i ++ ) \n   { \n     motorStep ( velocityArray [ i ],   i ); \n   }  }  void   setup ()  { \n   Serial . begin ( 115200 );   // set baud rate \n   nh . initNode ();   // Initialize ROSserial node \n\n   // notify master of our new publishers and subscribers \n   nh . subscribe ( motorVelocities ); \n   nh . advertise ( currentMotorVelocities_topic ); \n   nh . advertise ( angularDisplacements_topic ); \n\n   AFMSbot . begin ();   // Initialize the bottom shield \n   AFMStop . begin ();   // Initialize the top shield \n\n   // add motor instances to our motorArray \n   // ommited index=0 for clarity \n   motorArray [ 1 ]   =   stepMotor_1 ; \n   motorArray [ 2 ]   =   stepMotor_2 ; \n   motorArray [ 3 ]   =   stepMotor_3 ;  }  void   loop ()  { \n   // This causes ROS to cycle. \n   // Normally (on a multithreaded device) each subscriber \n   // works in its own thread. Because this device is  \n   // single threaded, this function aids in protothreading and making \n   // sure our values are updated accordingly. \n   nh . spinOnce (); \n\n   // Processes current desired velocities and sends the  \n   activateMotors (); \n\n   // step commands ot the motors// Publishes currrent motor velocities to  currentMotorVelocities_topic . \n   publishCurrentMotorVelocities ();   \n   // Publishes the angular displacement for the current iteration to  angularDisplacements_topic . \n   publishAngularDisplacements ();  }", 
            "title": "Motors Only (w/ ROS)"
        }, 
        {
            "location": "/codeBase/#sensors-only-w-ros", 
            "text": "'scripts/arduino/basicSensors_wROS.ino'  Begins reading data from arudino's onboard accelerometer and gyroscope. ROS is used to publish linear acceleration, orientation, and angular velocity. External power source not needed (only USB). No subscribers.    1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191 #include  ros.h   // ROS library  #include  CurieIMU.h   // accelerometer library  #include  MadgwickAHRS.h   // noise filter library  #include  geometry_msgs/Vector3.h   // ROS messages library  // Instantiate ROS handler object.  // (this makes it a ROS node)  ros :: NodeHandle   nh ;   // preallocate Vector3 variables to hold:  // --------------------------------------  // var orientation = orientation   // var linearAccel = linear acceleration  // var angularVel = angular velocity  geometry_msgs :: Vector3   orientation ;   geometry_msgs :: Vector3   linearAccel ;  geometry_msgs :: Vector3   angularVel ;  // Set up publishers for each of the variables above.  // Each of these publishers will publish each of the variables above,  // every time the arduino loop executes (activated by the  spinOnce  on line 141).  ros :: Publisher   orientation_topic ( orientation_topic ,   orientation );  ros :: Publisher   linearAccel_topic ( linearAccel_topic ,   linearAccel );  ros :: Publisher   angularVel_topic ( angularVel_topic ,   angularVel );  // Create a Madgwick object to access the functions from the   // Madgwick class in the library. Here, we call it filter.  // A prewritten class from ADAFRUIT website that will allow   // us to get a reading from the onboard gyroscope and accelerometer.  // https://www.arduino.cc/en/Tutorial/Genuino101CurieIMUOrientationVisualiser  Madgwick   filter ;  // initialize sensor data variables  unsigned   long   microsPerReading ,   microsPrevious ;  float   accelScale ,   gyroScale ;  // The algorithm takes raw values from a gyroscope and accelerometer,   // and uses them to return four quaternions:  int   aix ,   aiy ,   aiz ;  int   gix ,   giy ,   giz ;  float   ax ,   ay ,   az ;  float   gx ,   gy ,   gz ;  // which are 4-dimensional numbers which contain x, y, and z values to   // represent the axis around which rotation occurs, as well as a \u03c9 value  // which represents the value of rotation which occurs around the same   // axis. These quaternions can be used to calculate the Euler angles   // pitch, yaw, and roll.  float   roll ,   pitch ,   heading ;  unsigned   long   microsNow ;  // Helper functions for translating quarternion readings.  // Both are used in  publishLinearAccelAndangularVel()  float   convertRawAcceleration ( int   aRaw )   { \n   // since we are using 2G range \n   // -2g maps to a raw value of -32768 \n   // +2g maps to a raw value of 32767 \n\n   float   a   =   ( aRaw   *   2.0 )   /   32768.0 ; \n   return   a ;  }  float   convertRawGyro ( int   gRaw )   { \n   // since we are using 250 degrees/seconds range \n   // -250 maps to a raw value of -32768 \n   // +250 maps to a raw value of 32767 \n\n   float   g   =   ( gRaw   *   250.0 )   /   32768.0 ; \n   return   g ;  }  // This function takes care of three different tasks  // 1) Translatemrat raw quarternion readings to:  //    -Gs for linear accelration (line )  //    -Degrees/sec for angular velocity  // 2) Publish tranlated motion values to their respective topics  // 3) Update the the Madgwick object (the filter) to later obtain   //    our roll, pitch, and yaw  void   publishLinearAccelAndangularVel ()  { \n   // convert from raw data to gravity and degrees/second units \n   ax   =   convertRawAcceleration ( aix ); \n   ay   =   convertRawAcceleration ( aiy ); \n   az   =   convertRawAcceleration ( aiz ); \n   gx   =   convertRawGyro ( gix ); \n   gy   =   convertRawGyro ( giy ); \n   gz   =   convertRawGyro ( giz ); \n\n   // update the filter, which computes orientation \n   // we will call this filter in a separata function to get roll, pitch, yaw \n   filter . updateIMU ( gx ,   gy ,   gz ,   ax ,   ay ,   az ); \n\n   // attach linear accel and rotational vel values for publishing \n   linearAccel . x   =   ax ; \n   linearAccel . y   =   ay ; \n   linearAccel . z   =   az ; \n   angularVel . x   =   gx ; \n   angularVel . y   =   gy ; \n   angularVel . z   =   gz ; \n\n   // publish values \n   linearAccel_topic . publish (   linearAccel   ); \n   angularVel_topic . publish (   angularVel   );  }  // Retrieves roll, pitch, and yaw from the filter (Madgqiwck object)  // and publishes it to the orientation topic.  // Roll, pitch, and yaw are calculated according to the update performed on the filter   // from  publishLinearAccelAndangularVel()  function (runs beforehand).  void   publishOrientation ()  { \n   roll   =   filter . getRoll (); \n   pitch   =   filter . getPitch (); \n   heading   =   filter . getYaw (); \n\n   orientation . x   =   roll ; \n   orientation . y   =   pitch ; \n   orientation . z   =   heading ; \n\n   orientation_topic . publish (   orientation   );  }  // Checks to ensure its time to take a new reading, according to timestep defined  // inside of the  setup()  function.  // If its time for a reading, linearAcceleration, angularVelocity,a nd orientation are  // all read and published.  void   processAndPublishSensorData ()  { \n   // Timestep is calculated below. \n   // Configuration for the itme step is set in the  setup()  function. \n   microsNow   =   micros (); \n   if   ( microsNow   -   microsPrevious   =   microsPerReading )   { \n\n     // read raw data from CurieIMU and store in  aix, aiy, aiz, gix, giy, giz \n     // These variables are available globally! \n     CurieIMU . readMotionSensor ( aix ,   aiy ,   aiz ,   gix ,   giy ,   giz ); \n\n     publishLinearAccelAndangularVel (); \n     publishOrientation (); \n\n     // increment previous time, so we keep proper pace \n     microsPrevious   =   microsPrevious   +   microsPerReading ; \n   }  }  void   setup ()  { \n   // Set baud rate for serial transmission. \n   Serial . begin ( 115200 );  \n   // Initilizes the ROS node. \n   nh . initNode ();   \n\n   // Notify the master node that we have 3 publishers declared above. \n   nh . advertise ( orientation_topic ); \n   nh . advertise ( linearAccel_topic ); \n   nh . advertise ( angularVel_topic ); \n\n   // Start the IMU and perform preliminary configuration by  \n   // setting the sample rate of the acelerometer and the gyro  \n   // and the filter to 25Hz: \n   CurieIMU . begin (); \n   CurieIMU . setGyroRate ( 25 );   //25 Hz \n   CurieIMU . setAccelerometerRate ( 25 );   // 25Hz \n   filter . begin ( 25 );   // 25Hz \n\n   // Set the accelerometer range to 2G \n   CurieIMU . setAccelerometerRange ( 2 ); \n\n   // Set the gyroscope range to 250 degrees/second \n   CurieIMU . setGyroRange ( 250 ); \n\n   // initialize variables to pace updates to correct rate \n   microsPerReading   =   1000000   /   25 ; \n   microsPrevious   =   micros ();  }  void   loop ()  { \n   // This causes ROS to cycle. \n   // Normally (on a multithreaded device) each subscriber \n   // works in its own thread. Because this device is  \n   // single threaded, this function aids in protothreading and making \n   // sure our values are updated accordingly. \n   nh . spinOnce (); \n\n   // This line processes all other functions, preparing and publishing  \n   // all outgoing data. \n   processAndPublishSensorData ();  }", 
            "title": "Sensors Only (w/ ROS)"
        }, 
        {
            "location": "/codeBase/#motors-sensors-w-ros", 
            "text": "'scripts/arduino/motorsAndSensors_wROS.ino'  Starts up three motors and onboard accelerometer/gyroscope.\nSubscribes to velocity updates.\nPublishes angular dispacmeents, motor velocities, orientation, linear acceleration, and angular velocity.    1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284 // =================================================  // Motor Libraries [START] -------------------------  #include  Wire.h  #include  Adafruit_MotorShield.h  #include  ros.h  #include  std_msgs/Int64.h  #include  std_msgs/Float32MultiArray.h  #include  geometry_msgs/Point.h  #include  omnibot/MotorArray.h  // Motor Libraries [END] ---------------------------  // =================================================  // =================================================  // Sensor Libraries [START] ------------------------  #include  CurieIMU.h  #include  MadgwickAHRS.h  #include  geometry_msgs/Vector3.h  // Sensor Libraries [END] --------------------------  // =================================================  ros :: NodeHandle   nh ;  // ==============================================================  // Motor variable declaration [START]----------------------------  Adafruit_MotorShield   AFMStop ( 0x61 );  Adafruit_MotorShield   AFMSbot ( 0x60 );  Adafruit_StepperMotor   * stepMotor_1   =   AFMStop . getStepper ( 200 ,   2 );  Adafruit_StepperMotor   * stepMotor_2   =   AFMSbot . getStepper ( 200 ,   1 );  Adafruit_StepperMotor   * stepMotor_3   =   AFMSbot . getStepper ( 200 ,   2 );  Adafruit_StepperMotor *   motorArray [ 4 ];  float   velocityArray [ 4 ]   =   { 0 };   // initialize motors at angular_vel=0; available globally  float   velocityThreshold   =   0.1 ;  omnibot :: MotorArray   currentVelocities ;  omnibot :: MotorArray   angularDisplacements ;  ros :: Publisher   currentMotorVelocities_topic ( currentMotorVelocities_topic ,   currentVelocities );  ros :: Publisher   angularDisplacements_topic ( angularDisplacements_topic ,   angularDisplacements );  // Motor variable declaration [END]------------------------------  // ==============================================================  // ==============================================================  // Sensor variable declaration [START]----------------------------  geometry_msgs :: Vector3   orientation ;  geometry_msgs :: Vector3   linearAccel ;  geometry_msgs :: Vector3   angularVel ;  ros :: Publisher   linearAccel_topic ( linearAccel_topic ,   linearAccel );  ros :: Publisher   angularVel_topic ( angularVel_topic ,   angularVel );  ros :: Publisher   orientation_topic ( orientation_topic ,   orientation );  Madgwick   filter ;  unsigned   long   microsPerReading ,   microsPrevious ;  float   accelScale ,   gyroScale ;  int   aix ,   aiy ,   aiz ;  int   gix ,   giy ,   giz ;  float   ax ,   ay ,   az ;  float   gx ,   gy ,   gz ;  float   roll ,   pitch ,   heading ;  unsigned   long   microsNow ;  // Sensor variable declaration [END]------------------------------  // ==============================================================  // ==============================================================  // Motor function and callbacks [START]--------------------------  // callback function for subscriber below. Updates velocities from FIFO queue  void   updateMotorVelocities (   const   omnibot :: MotorArray   velocity_msg )  { \n   velocityArray [ 1 ]   =   velocity_msg . motor1 ;   velocityArray [ 2 ]   =   velocity_msg . motor2 ;   velocityArray [ 3 ]   =   velocity_msg . motor3 ; \n\n   motorArray [ 1 ] - setSpeed ( abs ( velocityArray [ 1 ])); \n   motorArray [ 2 ] - setSpeed ( abs ( velocityArray [ 2 ])); \n   motorArray [ 3 ] - setSpeed ( abs ( velocityArray [ 3 ]));  }  bool   velocityIsAboveThreshold ( float   motorVel ,   float   threshold )  { \n   if   (   abs ( motorVel )     threshold   )   { \n     return   true ; \n   } \n   return   false ;  }  float   getCurrentMotorVelocity ( float   velocity ,   float   threshold )  { \n\n   if   ( velocityIsAboveThreshold ( velocity ,   threshold ))   { \n     return   velocity ; \n   } \n   return   0 ;  }  float   getAngularDisplacement ( float   velocity )  { \n   if   ( velocity     0 )   { \n     return   0.0314159 ; \n   } \n   else   if ( velocity     0 )   { \n     return   - 0.0314159 ; \n   } \n   else   { \n     return   0 ; \n   }   }  void   motorStep ( float   motorVel ,   int   motorNumber )  { \n   if   ( velocityIsAboveThreshold ( motorVel ,   velocityThreshold ))   { \n     if ( motorVel     0 )   { \n       motorArray [ motorNumber ] - step ( 1 ,   BACKWARD ,   DOUBLE );   // clockwise \n     } \n     else   { \n       motorArray [ motorNumber ] - step ( 1 ,   FORWARD ,   DOUBLE );   // counter-clockwise \n     } \n   }  }  void   publishCurrentMotorVelocities ()  { \n   currentVelocities . motor1   =   getCurrentMotorVelocity ( velocityArray [ 1 ],   velocityThreshold ); \n   currentVelocities . motor2   =   getCurrentMotorVelocity ( velocityArray [ 2 ],   velocityThreshold ); \n   currentVelocities . motor3   =   getCurrentMotorVelocity ( velocityArray [ 3 ],   velocityThreshold ); \n\n   currentMotorVelocities_topic . publish (   currentVelocities   );  }  void   publishAngularDisplacements ()  {  \n   angularDisplacements . motor1   =   getAngularDisplacement ( currentVelocities . motor1 ); \n   angularDisplacements . motor2   =   getAngularDisplacement ( currentVelocities . motor2 ); \n   angularDisplacements . motor3   =   getAngularDisplacement ( currentVelocities . motor3 ); \n\n   angularDisplacements_topic . publish (   angularDisplacements   );  }  // Set up motorVelocities subscriber  ros :: Subscriber omnibot :: MotorArray   motorVelocities ( setStepMotorVelocity_topic ,   updateMotorVelocities   );  void   activateMotors ()  { \n   for ( int   i   =   1 ;   i     4 ;   i ++ ) \n   { \n     motorStep ( velocityArray [ i ],   i ); \n   }  }  // Motor function and callbacks [END]----------------------------  // ==============================================================  // ==============================================================  // Sensor function and callbacks [START]--------------------------  float   convertRawAcceleration ( int   aRaw )   { \n   // since we are using 2G range \n   // -2g maps to a raw value of -32768 \n   // +2g maps to a raw value of 32767 \n\n   float   a   =   ( aRaw   *   2.0 )   /   32768.0 ; \n   return   a ;  }  float   convertRawGyro ( int   gRaw )   { \n   // since we are using 250 degrees/seconds range \n   // -250 maps to a raw value of -32768 \n   // +250 maps to a raw value of 32767 \n\n   float   g   =   ( gRaw   *   250.0 )   /   32768.0 ; \n   return   g ;  }  void   publishLinearAndangularVel ()  { \n   ax   =   convertRawAcceleration ( aix ); \n   ay   =   convertRawAcceleration ( aiy ); \n   az   =   convertRawAcceleration ( aiz ); \n\n   gx   =   convertRawGyro ( gix ); \n   gy   =   convertRawGyro ( giy ); \n   gz   =   convertRawGyro ( giz ); \n\n   filter . updateIMU ( gx ,   gy ,   gz ,   ax ,   ay ,   az ); \n\n   linearAccel . x   =   ax ; \n   linearAccel . y   =   ay ; \n   linearAccel . z   =   az ; \n\n   angularVel . x   =   gx ; \n   angularVel . y   =   gy ; \n   angularVel . z   =   gz ; \n\n   linearAccel_topic . publish (   linearAccel   ); \n   angularVel_topic . publish (   angularVel   );  }  void   publishOrientation ()  { \n   roll   =   filter . getRoll (); \n   pitch   =   filter . getPitch (); \n   heading   =   filter . getYaw (); \n\n   orientation . x   =   roll ; \n   orientation . y   =   pitch ; \n   orientation . z   =   heading ; \n\n   orientation_topic . publish (   orientation   );  }  void   processAndPublishSensorData ()  { \n   microsNow   =   micros (); \n   if   ( microsNow   -   microsPrevious   =   microsPerReading )   { \n\n     // read raw data from CurieIMU \n     CurieIMU . readMotionSensor ( aix ,   aiy ,   aiz ,   gix ,   giy ,   giz ); \n\n     publishLinearAndangularVel (); \n     publishOrientation (); \n\n     // increment previous time, so we keep proper pace \n     microsPrevious   =   microsPrevious   +   microsPerReading ; \n   }  }  // Sensor function and callbacks [END]----------------------------  // ==============================================================  void   setup ()  { \n   Serial . begin ( 115200 );   // set baud rate \n   nh . initNode (); \n\n   // ============================================= \n   // Motor setup [START]-------------------------- \n   nh . subscribe ( motorVelocities ); \n   nh . advertise ( currentMotorVelocities_topic ); \n   nh . advertise ( angularDisplacements_topic ); \n\n   AFMSbot . begin (); \n   AFMStop . begin (); \n\n   motorArray [ 1 ]   =   stepMotor_1 ; \n   motorArray [ 2 ]   =   stepMotor_2 ; \n   motorArray [ 3 ]   =   stepMotor_3 ; \n   // Motor setup [END]-------------------------- \n   // =========================================== \n\n   // ============================================= \n   // Sensor setup [START]-------------------------- \n   nh . advertise ( orientation_topic ); \n   nh . advertise ( linearAccel_topic ); \n   nh . advertise ( angularVel_topic ); \n\n   CurieIMU . begin (); \n   CurieIMU . setGyroRate ( 25 ); \n   CurieIMU . setAccelerometerRate ( 25 ); \n   filter . begin ( 25 ); \n\n   CurieIMU . setAccelerometerRange ( 2 ); \n   CurieIMU . setGyroRange ( 250 ); \n\n   microsPerReading   =   1000000   /   25 ; \n   microsPrevious   =   micros (); \n   // Sensor setup [END]-------------------------- \n   // ===========================================  }  void   loop ()  { \n   nh . spinOnce (); \n   // ==================================================== \n   // Motor loop [START]---------------------------------- \n   activateMotors (); \n   publishCurrentMotorVelocities (); \n   publishAngularDisplacements (); \n   // Motor loop [END]---------------------------------- \n   // ==================================================== \n   // ==================================================== \n   // Sensor loop [START]---------------------------------- \n   processAndPublishSensorData (); \n   // Sensor loop [END]---------------------------------- \n   // ====================================================  }", 
            "title": "Motors + Sensors (w/ ROS)"
        }, 
        {
            "location": "/codeBase/#script-files-dev-only", 
            "text": "", 
            "title": "Script Files (Dev Only)"
        }, 
        {
            "location": "/codeBase/#velocity-publisher-node", 
            "text": "'scripts/velocityPublisher_node.py'  Sets up motor velocities at 100 rpms each.\nBegins decreasing velocity at 1rpm per cycle (1 second)\nMotors will chnage direction, when velocities become negative.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38 #!/usr/bin/env python  import   rospy   #import ROS pip package for using ROS library  from   omnibot.msg   import   MotorArray   # import our custom ROS msg types  def   VelocityPublisher_talker (): \n     # Declare publisher \n     # Transmitting to =  setStepMotorVelocity_topic \n     # Using the  MotorArray  message type \n     # A maximnum of 10 messages will be held in the message queue. \n     pub   =   rospy . Publisher ( setStepMotorVelocity_topic ,   MotorArray ,   queue_size = 10 ) \n\n     # Initialize node \n     rospy . init_node ( velocityPublisher_node ) \n\n     # Sets ROS to cycle at frequency of 1Hz \n     rate   =   rospy . Rate ( 1 )  \n\n     # Set uinitial velocity to 100 rpms \n     velocity = 100.00 \n\n     # This keeps the node running until the script is shut down manually. \n     # node will keep cycling at the frequncy set above. \n     while   not   rospy . is_shutdown ():  \n         # Velocity decreases by 1 rpm every cycle \n         velocity   -=   1.0 \n         # Logs our MotorArray to the terminal \n         rospy . loginfo ([ velocity , velocity , velocity ]) \n         # Publishes our motorArray to the  setStepMotorVelocity_topic \n         pub . publish ( velocity , velocity , velocity ) \n         # Causes the while loop to pause until its time to cycle again. \n         # How long it sleeps (pauses) depends on our declared frequnecy above. \n         rate . sleep ()  if   __name__   ==   __main__ : \n     try : \n         VelocityPublisher_talker () \n     except   rospy . ROSInterruptException : \n         pass", 
            "title": "Velocity Publisher Node"
        }, 
        {
            "location": "/codeBase/#velocity-publisher-node-1", 
            "text": "'scripts/velocityPublisher_node_1.py'  Starts the motors at 30 rpm.\nCauses the motors to alternate directions every 5 seconds.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23 #!/usr/bin/env python  import   time  import   rospy  from   omnibot.msg   import   MotorArray  # Starts the motors at 30 rpm.  # Causes the motors to alternate directions every 5 seconds.  def   VelocityPublisher_talker (): \n     pub   =   rospy . Publisher ( setStepMotorVelocity_topic ,   MotorArray ,   queue_size = 10 ) \n     rospy . init_node ( velocityPublisher_node ) \n     rate   =   rospy . Rate ( 1 ) \n     velocity   =   30.00 \n     while   not   rospy . is_shutdown (): \n         velocity   =   velocity   *   ( - 1 )  \n         pub . publish ( velocity , velocity , velocity ) \n         time . sleep ( 5 )  if   __name__   ==   __main__ : \n     try : \n         VelocityPublisher_talker () \n     except   rospy . ROSInterruptException : \n         pass", 
            "title": "Velocity Publisher Node 1"
        }, 
        {
            "location": "/codeBase/#velocity-publisher-node-2", 
            "text": "'scripts/velocityPublisher_node_2.py'  Displays both directions for each motor in the following order.\nVelocities in either direction ar set to 30 rpm.\nScenarios alternate every 5 seconds.  Set -  1\nMotor1 = CCW; Motor2 = CCW; Motor3= CCW  Set -  2\nMotor1 = 0; Motor2 = 0; Motor3= 0  Set -  3\nMotor1 = CW; Motor2 = CW; Motor3= CW  Set -  4\nMotor1 = CCW; Motor2 = 0; Motor3= CW   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43 #!/usr/bin/env python  import   time  import   rospy  from   omnibot.msg   import   MotorArray  # Displays both directions for each motor in the following order.  # Velocities in either direction ar set to 30 rpm.  # Scenarios alternate every 5 seconds.  # Set -  1  # Motor1 = CCW; Motor2 = CCW; Motor3= CCW  # Set -  2  # Motor1 = 0; Motor2 = 0; Motor3= 0  # Set -  3  # Motor1 = CW; Motor2 = CW; Motor3= CW  # Set -  4  # Motor1 = CCW; Motor2 = 0; Motor3= CW  def   VelocityPublisher_talker (): \n     pub   =   rospy . Publisher ( setStepMotorVelocity_topic ,   MotorArray ,   queue_size = 10 ) \n     rospy . init_node ( velocityPublisher_node ) \n     rate   =   rospy . Rate ( 1 )   # 10hz \n     pos_velocity   =   30.00 \n     no_velocity   =   0 \n     neg_velocity   =   - 30.00 \n     while   not   rospy . is_shutdown (): \n         time . sleep ( 5 ) \n         pub . publish ( pos_velocity , pos_velocity , pos_velocity ) \n         time . sleep ( 5 ) \n         pub . publish ( no_velocity , no_velocity , no_velocity ) \n         time . sleep ( 5 ) \n         pub . publish ( neg_velocity , neg_velocity , neg_velocity ) \n         time . sleep ( 5 ) \n         pub . publish ( pos_velocity , no_velocity , neg_velocity )  if   __name__   ==   __main__ : \n     try : \n         VelocityPublisher_talker () \n     except   rospy . ROSInterruptException : \n         pass", 
            "title": "Velocity Publisher Node 2"
        }, 
        {
            "location": "/serialLatency/", 
            "text": "Serial Latency\n\n\nLatency in our Stack\n\n\nThere are significant advantages to using Linux as a complete OS, but there are often reservations about its real-time performance.\nThe official definition of real-time computing is a task that is executed within a given time, giving a deterministic system. Some applications need only an average response time, while others require that every deadline is met every time.\n\n\nGiven the architecture planned for our robot's stack, the following question is asked:\n\n\nCan our ROS setup maintain message transmission rates under 0.01s?\n\n\n\n\nNote: 0.01s restriction is necessary for our control algorithms to run effectively under any choice of parameters mentioned below.\n\n\n\n\nBecause we are utilizing Ubuntu (Not a RTOS) on our Pi, our system inherits unknown time delays between processes/tasks. In particular, there is latency in the serial communication between our Pi and our Arduino that we needed to investigate.\n\n\n\n\nSerial data exchanged between the Pi and Arduino is of particular concern to our robot's ability to:\n\n\n\n\nAvoid obstacles\n\n\nCollect data\n\n\nConverge to desired velocities, as guided by our control algorithms\n\n\nAsynchronous commands (including emergency terminations)\n\n\n\n\nParameters\n\n\nLatency in serial communication across our boards can be considered a function of the following:\n\n\n\n\nPhysical limits of serial transmission =\n This involves the limits on the Pi and Arduino to transmit and receive serial data, as well on the limits imposed by the transmission cable itself. Because these limits cannot be modified via software, these are not considered parameters in our solution space.\n\n\nROS topic queue lengths =\n FIFO queues utilized in ROS topic transmissions may cause a message to be processed when it is no longer relevant (seconds, milliseconds late). We want to keep this parameter as small as possible, but not small enough that we lose data necessary for intermittent steps.\n\n\nROS topic frequencies =\n This parameter (expressed in Hz) dictates how often messages are exchanged, per second. On a full OS, each publisher and subscriber is carried out in its own separate thread. The single-threaded nature of the Arduino introduces additional complexity to our latency calculations, as multiplexing must occur for the Arduino to feature multiple publishers/transmitters.\n\n\nROS message sizes =\n Inherently, the time taken to transmit a message will be proportional to the size of the message itself.\n\n\nROS stack serialization time =\n ROS performs XML serialization on messages exchanged between nodes. Although small, it is noteworthy that there is a source of duration associated to serialization between the Arduino and Pi.\n\n\nSerial baud rate =\n the rate at which information is transferred in a communication channel. In the serial port context, \"9600 baud\" means that the serial port is capable of transferring a maximum of 9600 bits per second. This parameter is bounded by he clock speed on the Arduino.\n\n\n\n\nSolution Space\n\n\nMinimal time delays in serial communication, within our stack can be achieved by choosing an optimal combination of: Baud Rate, Message Type (size implied), Topic frequency, and Queue length. The entire solution space consists of all possible combinations of these parameters, which would only be bounded by the physical limits of the boards and cable.\n\n\nQueue Length\n\n\n\n\n1, 5, 10, 20, 50, 100\n\n\n\n\nFrequency\n\n\n\n\n5, 10, 20, 50, 100, 200\n\n\n\n\nBaud Rate\n\n\n\n\n9600, 57600, 115200, 128000, 256000, 1000000, 2000000\n\n\n\n\nProcedures\n\n\nUsing python, bash scripting, and Arduino's CLI, we automated the testing of a large portion of the entire solution space.\n\n\nPreliminary Steps\n\n\nTwo dummy scripts were made (Arduino Subscriber \n Python Publisher), that served as templates. At each iteration, the templates were used to create a new script (with new parameters) that was deployed and ran using ROS.\n\n\nTesting Workflow\n\n\n\n\nNOTE: The red box above is expanded below. This is the data collection process.\n\n\n\n\nData Collection and Processing\n\n\nSample log file\n\n\n\n\n\n\nOur log files collected timestamps that were transmitted via ROS topic, as shown above.\n\n\nUsing MATLAB and Pandas, we calculated the maximum latency in each test case. We then proceeded to take the maximum latency, form the collection of maximum latencies.\n\n\n\n\nFindings\n\n\nMaximum latency found\n\n\n\n\n\n\n\n\nOur tests concluded that our ROS stack kept transmission times under 0.01s. Our maximum latency came at 8164965ns (0.008s), under the following parameters:\n\n\nFrequency: 10Hz | Queue Size: 1 | Baud Rate: 9600\n\n\n\n\n\n\nTest results allowed us to proceed in development knowing that our stack (control algorithms) would perform as intended, given that we remain within the minimum-maximum parameters tested.\n\n\n\n\n\n\nLatency Module\n\n\n\n\nThe entire testing module can be found and ran in our repository, under \"latency_module\".", 
            "title": "Serial Latency"
        }, 
        {
            "location": "/serialLatency/#serial-latency", 
            "text": "", 
            "title": "Serial Latency"
        }, 
        {
            "location": "/serialLatency/#latency-in-our-stack", 
            "text": "There are significant advantages to using Linux as a complete OS, but there are often reservations about its real-time performance.\nThe official definition of real-time computing is a task that is executed within a given time, giving a deterministic system. Some applications need only an average response time, while others require that every deadline is met every time.  Given the architecture planned for our robot's stack, the following question is asked:  Can our ROS setup maintain message transmission rates under 0.01s?   Note: 0.01s restriction is necessary for our control algorithms to run effectively under any choice of parameters mentioned below.   Because we are utilizing Ubuntu (Not a RTOS) on our Pi, our system inherits unknown time delays between processes/tasks. In particular, there is latency in the serial communication between our Pi and our Arduino that we needed to investigate.   Serial data exchanged between the Pi and Arduino is of particular concern to our robot's ability to:   Avoid obstacles  Collect data  Converge to desired velocities, as guided by our control algorithms  Asynchronous commands (including emergency terminations)", 
            "title": "Latency in our Stack"
        }, 
        {
            "location": "/serialLatency/#parameters", 
            "text": "Latency in serial communication across our boards can be considered a function of the following:   Physical limits of serial transmission =  This involves the limits on the Pi and Arduino to transmit and receive serial data, as well on the limits imposed by the transmission cable itself. Because these limits cannot be modified via software, these are not considered parameters in our solution space.  ROS topic queue lengths =  FIFO queues utilized in ROS topic transmissions may cause a message to be processed when it is no longer relevant (seconds, milliseconds late). We want to keep this parameter as small as possible, but not small enough that we lose data necessary for intermittent steps.  ROS topic frequencies =  This parameter (expressed in Hz) dictates how often messages are exchanged, per second. On a full OS, each publisher and subscriber is carried out in its own separate thread. The single-threaded nature of the Arduino introduces additional complexity to our latency calculations, as multiplexing must occur for the Arduino to feature multiple publishers/transmitters.  ROS message sizes =  Inherently, the time taken to transmit a message will be proportional to the size of the message itself.  ROS stack serialization time =  ROS performs XML serialization on messages exchanged between nodes. Although small, it is noteworthy that there is a source of duration associated to serialization between the Arduino and Pi.  Serial baud rate =  the rate at which information is transferred in a communication channel. In the serial port context, \"9600 baud\" means that the serial port is capable of transferring a maximum of 9600 bits per second. This parameter is bounded by he clock speed on the Arduino.", 
            "title": "Parameters"
        }, 
        {
            "location": "/serialLatency/#solution-space", 
            "text": "Minimal time delays in serial communication, within our stack can be achieved by choosing an optimal combination of: Baud Rate, Message Type (size implied), Topic frequency, and Queue length. The entire solution space consists of all possible combinations of these parameters, which would only be bounded by the physical limits of the boards and cable.", 
            "title": "Solution Space"
        }, 
        {
            "location": "/serialLatency/#queue-length", 
            "text": "1, 5, 10, 20, 50, 100", 
            "title": "Queue Length"
        }, 
        {
            "location": "/serialLatency/#frequency", 
            "text": "5, 10, 20, 50, 100, 200", 
            "title": "Frequency"
        }, 
        {
            "location": "/serialLatency/#baud-rate", 
            "text": "9600, 57600, 115200, 128000, 256000, 1000000, 2000000", 
            "title": "Baud Rate"
        }, 
        {
            "location": "/serialLatency/#procedures", 
            "text": "Using python, bash scripting, and Arduino's CLI, we automated the testing of a large portion of the entire solution space.", 
            "title": "Procedures"
        }, 
        {
            "location": "/serialLatency/#preliminary-steps", 
            "text": "Two dummy scripts were made (Arduino Subscriber   Python Publisher), that served as templates. At each iteration, the templates were used to create a new script (with new parameters) that was deployed and ran using ROS.", 
            "title": "Preliminary Steps"
        }, 
        {
            "location": "/serialLatency/#testing-workflow", 
            "text": "NOTE: The red box above is expanded below. This is the data collection process.", 
            "title": "Testing Workflow"
        }, 
        {
            "location": "/serialLatency/#data-collection-and-processing", 
            "text": "", 
            "title": "Data Collection and Processing"
        }, 
        {
            "location": "/serialLatency/#sample-log-file", 
            "text": "Our log files collected timestamps that were transmitted via ROS topic, as shown above.  Using MATLAB and Pandas, we calculated the maximum latency in each test case. We then proceeded to take the maximum latency, form the collection of maximum latencies.", 
            "title": "Sample log file"
        }, 
        {
            "location": "/serialLatency/#findings", 
            "text": "", 
            "title": "Findings"
        }, 
        {
            "location": "/serialLatency/#maximum-latency-found", 
            "text": "Our tests concluded that our ROS stack kept transmission times under 0.01s. Our maximum latency came at 8164965ns (0.008s), under the following parameters:  Frequency: 10Hz | Queue Size: 1 | Baud Rate: 9600    Test results allowed us to proceed in development knowing that our stack (control algorithms) would perform as intended, given that we remain within the minimum-maximum parameters tested.", 
            "title": "Maximum latency found"
        }, 
        {
            "location": "/serialLatency/#latency-module", 
            "text": "The entire testing module can be found and ran in our repository, under \"latency_module\".", 
            "title": "Latency Module"
        }, 
        {
            "location": "/wifiLocalization/", 
            "text": "Wifi Localization\n\n\nRSSI-based self-loclaization is utilized as a substitute for Bluetooth and/or GPS localization.\nOur module was designed entirely around Xiuyan Zhu's and Yuan Feng's 'RSSI-based Algorithm for Indoor Localization' \npaper, published here: https://file.scirp.org/pdf/CN_2013071010352139.pdf\n\n\nUsing the wifi signal detected from three separate access points, we can use the log-model (as described in the paper) \nto estimate our distance from each access point. With a distance estimated fomr each node, we use the trilateral-localization\nalgortihm to estimate a location.\n\n\nNote: The location of each node must not be fixed, but must be specified.\n\n\nLog Model\nCS = Current Signal from node x\nRS = Reference Signal for node x\nCD = Current Distance from node x\nRD = Reference Distance for node x\nn = Signal Attenuation Factor\nlog = log w/base-10\n\n\n[CS] = [RS]-[10*nlog(CD/RD)]\n\n\nSolving for CD:\n[Beta] = [(RS-CS)/(10\nn)]\n[CD] = [10^Beta]\n[RD]\n\n\nFor more information on the python rssi module, visit: \nhttps://github.com/jvillagomez/rssi_module\n\n\nRSSI Module\n\n\nScan Class\n\n\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n#!/usr/bin/env python\n\n\n# RSSI_Scan\n\n    \n# Use:\n\n        \n# from rssi import RSSI_Scan\n\n        \n# rssi_scan_instance = RSSI_Scan(\nnetwork_interface_name) \n\n    \n# -------------------------------------------------------\n\n    \n# Description:\n\n        \n# Allows a user to query all available accesspoints available.\n\n        \n# User has the option of define a specific set of access \n\n        \n# points to query.\n\n    \n# -------------------------------------------------------\n\n    \n# Input: interface name\n\n        \n# [ie. network interface names: wlp1s0m, docker0, wlan0] \n\n\nclass\n \nRSSI_Scan\n(\nobject\n):\n\n    \n# Allows us to declare a network interface externally.\n\n    \ndef\n \n__init__\n(\nself\n,\n \ninterface\n):\n\n        \nself\n.\ninterface\n \n=\n \ninterface\n\n\n    \n# getRawNetworkScan\n\n        \n# Description:\n\n            \n# Runs the Ubuntu command \niwlist\n to scan for available networks.\n\n            \n# Returns the raw console window output (unparsed).\n\n        \n# ----------------------------------------------------------------\n\n        \n# Input: (optional) \n\n            \n#   sudo: bool; defaults to false. False will not refresh the \n\n            \n#         network interface upon query. Sudo=true will require \n\n            \n#         the user will need to enter a sudo password at runtime.\n\n        \n# ----------------------------------------------------------------\n\n        \n# Returns: Raw terminal output\n\n            \n# {\n\n            \n#     \noutput\n:\nwlp1s0    Scan completed :\n\n            \n#   Cell 01 - Address: A0:3D:6F:26:77:8E\n\n            \n#             Channel:144\n\n            \n#             Frequency:5.72 GHz\n\n            \n#             Quality=43/70  Signal level=-67 dBm  \n\n            \n#             Encryption key:on\n\n            \n#             ESSID:\nucrwpa\n\n            \n#             Bit Rates:24 Mb/s; 36 Mb/s; 48 Mb/s; 54 Mb/s\n\n            \n#             Mode:Master\n\n            \n#   Cell 02 - Address: A0:3D:6F:26:77:82\n\n            \n#             Channel:1\n\n            \n#             Frequency:2.412 GHz (Channel 1)\n\n            \n#             Quality=43/70  Signal level=-67 dBm  \n\n            \n#             Encryption key:on\n\n            \n#             ESSID:\neduroam\n\n            \n#             Bit Rates:18 Mb/s; 24 Mb/s; 36 Mb/s; 48 Mb/s; 54 Mb/s\n\n            \n#             Mode:Master\n,\n\n            \n#     \nerror\n:\n\n            \n# }\n\n    \ndef\n \ngetRawNetworkScan\n(\nself\n,\n \nsudo\n=\nFalse\n):\n\n        \n# Scan command \niwlist interface scan\n needs to be fed as an array.\n\n        \nif\n \nsudo\n:\n\n            \nscan_command\n \n=\n \n[\nsudo\n,\niwlist\n,\nself\n.\ninterface\n,\nscan\n]\n\n        \nelse\n:\n\n            \nscan_command\n \n=\n \n[\niwlist\n,\nself\n.\ninterface\n,\nscan\n]\n\n        \n# Open a subprocess running the scan command.\n\n        \nscan_process\n \n=\n \nPopen\n(\nscan_command\n,\n \nstdout\n=\nPIPE\n,\n \nstderr\n=\nPIPE\n)\n\n        \n# Block all execution, until the scanning completes.\n\n        \nscan_process\n.\nwait\n()\n\n        \n# Returns the \nsuccess\n and \nerror\n output.\n\n        \n(\nraw_output\n,\n \nraw_error\n)\n \n=\n \nscan_process\n.\ncommunicate\n()\n \n        \n# Returns all output in a dictionary for easy retrieval.\n\n        \nreturn\n \n{\noutput\n:\nraw_output\n,\nerror\n:\nraw_error\n}\n\n\n    \n# getSSID\n\n        \n# Description:\n\n            \n# Parses the \nSSID\n for a given cell.\n\n        \n# -----------------------------------------------\n\n        \n# Input: (Raw string)\n\n            \n# 01 - Address: A0:3D:6F:26:77:8E\n\n            \n# Channel:144\n\n            \n# Frequency:5.72 GHz\n\n            \n# Quality=43/70  Signal level=-67 dBm  \n\n            \n# Encryption key:on\n\n            \n# ESSID:\nucrwpa\n\n            \n# Bit Rates:24 Mb/s; 36 Mb/s; 48 Mb/s; 54 Mb/s\n\n            \n# Mode:Master\n\n        \n# -----------------------------------------------\n\n        \n# Returns:\n\n            \n# \nucrwpa\n\n    \n@staticmethod\n\n    \ndef\n \ngetSSID\n(\nraw_cell\n):\n\n        \nssid\n \n=\n \nraw_cell\n.\nsplit\n(\nESSID:\n)[\n1\n]\n\n        \nssid\n \n=\n \nssid\n.\nsplit\n(\n)[\n0\n]\n\n        \nreturn\n \nssid\n\n\n    \n# getQuality\n\n        \n# Description:\n\n            \n# Parses \nQuality level\n for a given cell.\n\n        \n# -----------------------------------------------\n\n        \n# Input: (Raw string)\n\n            \n# 01 - Address: A0:3D:6F:26:77:8E\n\n            \n# Channel:144\n\n            \n# Frequency:5.72 GHz\n\n            \n# Quality=43/70  Signal level=-67 dBm  \n\n            \n# Encryption key:on\n\n            \n# ESSID:\nucrwpa\n\n            \n# Bit Rates:24 Mb/s; 36 Mb/s; 48 Mb/s; 54 Mb/s\n\n            \n# Mode:Master\n\n        \n# -----------------------------------------------\n\n        \n# Returns:\n\n            \n# \n43/70\n\n    \n@staticmethod\n\n    \ndef\n \ngetQuality\n(\nraw_cell\n):\n\n        \nquality\n \n=\n \nraw_cell\n.\nsplit\n(\nQuality=\n)[\n1\n]\n\n        \nquality\n \n=\n \nquality\n.\nsplit\n(\n \n)[\n0\n]\n\n        \nreturn\n \nquality\n\n\n    \n# getSignalLevel\n\n        \n# Description:\n\n            \n# Parses \nSignal level\n for a given cell.\n\n            \n# Measurement is in \ndBm\n.\n\n        \n# -----------------------------------------------\n\n        \n# Input: (Raw string)\n\n            \n# 01 - Address: A0:3D:6F:26:77:8E\n\n            \n# Channel:144\n\n            \n# Frequency:5.72 GHz\n\n            \n# Quality=43/70  Signal level=-67 dBm  \n\n            \n# Encryption key:on\n\n            \n# ESSID:\nucrwpa\n\n            \n# Bit Rates:24 Mb/s; 36 Mb/s; 48 Mb/s; 54 Mb/s\n\n            \n# Mode:Master\n\n        \n# -----------------------------------------------\n\n        \n# Returns: (string)\n\n            \n# \n-67\n    \n\n    \n@staticmethod\n\n    \ndef\n \ngetSignalLevel\n(\nraw_cell\n):\n\n        \nsignal\n \n=\n \nraw_cell\n.\nsplit\n(\nSignal level=\n)[\n1\n]\n\n        \nsignal\n \n=\n \nint\n(\nsignal\n.\nsplit\n(\n \n)[\n0\n])\n\n        \nreturn\n \nsignal\n\n\n    \n# parseCell\n\n        \n# Description:\n\n            \n# Takes a raw cell string and parses it into a dictionary.\n\n        \n# -----------------------------------------------\n\n        \n# Input: (Raw string)\n\n            \n# \n01 - Address: A0:3D:6F:26:77:8E\n\n            \n# Channel:144\n\n            \n# Frequency:5.72 GHz\n\n            \n# Quality=43/70  Signal level=-67 dBm  \n\n            \n# Encryption key:on\n\n            \n# ESSID:\nucrwpa\n\n            \n# Bit Rates:24 Mb/s; 36 Mb/s; 48 Mb/s; 54 Mb/s\n\n            \n# Mode:Master\n\n        \n# -----------------------------------------------\n\n        \n# Returns:\n\n            \n# {\n\n            \n#     \nssid\n:\nucrwpa\n,\n\n            \n#     \nquality\n:\n43/70\n,\n\n            \n#     \nsignal\n:\n-67\n\n            \n# }    \n\n    \ndef\n \nparseCell\n(\nself\n,\n \nraw_cell\n):\n\n        \ncell\n \n=\n \n{\n\n            \nssid\n:\n \nself\n.\ngetSSID\n(\nraw_cell\n),\n\n            \nquality\n:\n \nself\n.\ngetQuality\n(\nraw_cell\n),\n\n            \nsignal\n:\n \nself\n.\ngetSignalLevel\n(\nraw_cell\n)\n\n        \n}\n\n        \nreturn\n \ncell\n\n\n    \n# formatCells\n\n        \n# Description:\n\n            \n# Every network listed is considered a \ncell.\n\n            \n# This function parses each cell into a dictionary.\n\n            \n# Returns list of dictionaries. Makes use of \nparseCell\n.\n\n            \n# If not networks were detected, returns False.\n\n        \n# -----------------------------------------------\n\n        \n# Input: (Raw terminal string)\n\n            \n# \n01 - Address: A0:3D:6F:26:77:8E\n\n            \n# Channel:144\n\n            \n# Frequency:5.72 GHz\n\n            \n# Quality=43/70  Signal level=-67 dBm  \n\n            \n# Encryption key:on\n\n            \n# ESSID:\nucrwpa\n\n            \n# Bit Rates:24 Mb/s; 36 Mb/s; 48 Mb/s; 54 Mb/s\n\n            \n# Mode:Master\n\n            \n# 02 - Address: A0:3D:6F:26:77:8E\n\n            \n# Channel:144\n\n            \n# Frequency:5.72 GHz\n\n            \n# Quality=30/70  Signal level=-42 dBm  \n\n            \n# Encryption key:on\n\n            \n# ESSID:\ndd-wrt\n\n            \n# Bit Rates:24 Mb/s; 36 Mb/s; 48 Mb/s; 54 Mb/s\n\n            \n# Mode:Master\n\n        \n# -----------------------------------------------\n\n        \n# Returns: (Array of dictionaries)\n\n            \n# [\n\n            \n#     {\n\n            \n#         \nssid\n:\nucrwpa\n,\n\n            \n#         \nquality\n:\n43/70\n,\n\n            \n#         \nsignal\n:\n-67\n\n            \n#     },\n\n            \n#     {\n\n            \n#         \nssid\n:\ndd-wrt\n,\n\n            \n#         \nquality\n:\n30/70\n,\n\n            \n#         \nsignal\n:\n-42\n\n            \n#     }\n\n            \n# ]    \n\n    \ndef\n \nformatCells\n(\nself\n,\n \nraw_cell_string\n):\n\n        \nraw_cells\n \n=\n \nraw_cell_string\n.\nsplit\n(\nCell\n)\n \n# Divide raw string into raw cells.\n\n        \nraw_cells\n.\npop\n(\n0\n)\n \n# Remove unneccesary \nScan Completed\n message.\n\n        \nif\n(\nlen\n(\nraw_cells\n)\n \n \n0\n):\n \n# Continue execution, if atleast one network is detected.\n\n            \n# Iterate through raw cells for parsing.\n\n            \n# Array will hold all parsed cells as dictionaries.\n\n            \nformatted_cells\n \n=\n \n[\nself\n.\nparseCell\n(\ncell\n)\n \nfor\n \ncell\n \nin\n \nraw_cells\n]\n\n            \n# Return array of dictionaries, containing cells.\n\n            \nreturn\n \nformatted_cells\n\n        \nelse\n:\n\n            \nprint\n(\nNetworks not detected.\n)\n\n            \nreturn\n \nFalse\n\n        \n# TODO implement function in ndoe to process this boolean (False)\n\n\n    \n# filterAccessPoints\n\n        \n# Description:\n\n            \n# If the \nnetworks\n parameter is passed to the \ngetAPinfo\n\n            \n# function, then this method will filter out all irrelevant \n\n            \n# access-points. Access points specified in \nnetworks\n array \n\n            \n# will be returned (if available).\n\n        \n# -----------------------------------------------\n\n        \n# Input: (Parsed array of cell dictionaries)\n\n            \n# all_access_points = \n\n            \n# [\n\n            \n#     {\n\n            \n#         \nssid\n:\nucrwpa\n,\n\n            \n#         \nquality\n:\n43/70\n,\n\n            \n#         \nsignal\n:\n-67\n\n            \n#     },\n\n            \n#     {\n\n            \n#         \nssid\n:\ndd-wrt\n,\n\n            \n#         \nquality\n:\n30/70\n,\n\n            \n#         \nsignal\n:\n-42\n\n            \n#     },\n\n            \n#     {\n\n            \n#         \nssid\n:\nlinksys\n,\n\n            \n#         \nquality\n:\n58/70\n,\n\n            \n#         \nsignal\n:\n-24\n\n            \n#     }\n\n            \n# ] \n\n            \n# network_names = (array of network names)\n\n            \n# [\nucrwpa\n,\ndd-wrt\n]\n\n        \n# -----------------------------------------------\n\n        \n# Returns: (Array of dictionaries)\n\n            \n# [\n\n            \n#     {\n\n            \n#         \nssid\n:\nucrwpa\n,\n\n            \n#         \nquality\n:\n43/70\n,\n\n            \n#         \nsignal\n:\n-67\n\n            \n#     },\n\n            \n#     {\n\n            \n#         \nssid\n:\ndd-wrt\n,\n\n            \n#         \nquality\n:\n30/70\n,\n\n            \n#         \nsignal\n:\n-42\n\n            \n#     }\n\n            \n# ] \n\n    \n@staticmethod\n\n    \ndef\n \nfilterAccessPoints\n(\nall_access_points\n,\n \nnetwork_names\n):\n\n        \nfocus_points\n \n=\n \n[]\n \n# Array holding the access-points of concern.\n\n        \n# Iterate throguh all access-points found.\n\n        \nfor\n \npoint\n \nin\n \nall_access_points\n:\n\n            \n# Check if current AP is in our desired list.\n\n            \nif\n \npoint\n[\nssid\n]\n \nin\n \nnetwork_names\n:\n\n                \nfocus_points\n.\nappend\n(\npoint\n)\n\n        \nreturn\n \nfocus_points\n\n        \n# TODO implement something incase our desired ones were not found\n\n\n    \n# getAPinfo\n\n        \n# Description:\n\n            \n# Method returns all (or chosen) available access points (in range).\n\n            \n# Takes 2 optional parameters: \n\n            \n#   \nnetworks\n (array): \n\n            \n#       Lists all ssid\ns of concern. Will return only the available access \n\n            \n#       points listed here. If not provided, will return ALL access-points in range.        \n\n            \n#   \nsudo\n (bool): \n\n            \n#       Whether of not method should use sudo privileges. If user uses sudo\n\n            \n#       privileges, the network manager will be refreshed and will return \n\n            \n#       a fresh list of access-points available. If sudo is not provided, \n\n            \n#       a cached list will be returned. Cached list gets updated periodically.\n\n        \n# -----------------------------------------------\n\n        \n# Input: (Parsed array of cell dictionaries)\n\n            \n# networks = (array of network names)\n\n            \n# [\nucrwpa\n,\ndd-wrt\n]\n\n            \n# sudo = True || False\n\n        \n# -----------------------------------------------\n\n        \n# Returns: (Array of dictionaries)\n\n            \n# [\n\n            \n#     {\n\n            \n#         \nssid\n:\nucrwpa\n,\n\n            \n#         \nquality\n:\n43/70\n,\n\n            \n#         \nsignal\n:\n-67\n\n            \n#     },\n\n            \n#     {\n\n            \n#         \nssid\n:\ndd-wrt\n,\n\n            \n#         \nquality\n:\n30/70\n,\n\n            \n#         \nsignal\n:\n-42\n\n            \n#     }\n\n            \n# ] \n\n    \ndef\n \ngetAPinfo\n(\nself\n,\n \nnetworks\n=\nFalse\n,\n \nsudo\n=\nFalse\n):\n\n        \n# TODO implement error callback if error is raise in subprocess\n\n        \n# Unparsed access-point listing. AccessPoints are strings.\n\n        \nraw_scan_output\n \n=\n \nself\n.\ngetRawNetworkScan\n(\nsudo\n)[\noutput\n]\n \n        \n# Parsed access-point listing. Access-points are dictionaries.\n\n        \nall_access_points\n \n=\n \nself\n.\nformatCells\n(\nraw_scan_output\n)\n\n        \n# Checks if access-points were found.\n\n        \nif\n \nall_access_points\n:\n\n            \n# Checks if specific networks were declared.\n\n            \nif\n \nnetworks\n:\n\n                \n# Return specific access-points found.\n\n                \nreturn\n \nself\n.\nfilterAccessPoints\n(\nall_access_points\n,\n \nnetworks\n)\n\n            \nelse\n:\n\n                \n# Return ALL access-points found.\n\n                \nreturn\n \nall_access_points\n\n        \nelse\n:\n\n            \n# No access-points were found. \n\n            \nreturn\n \nFalse\n\n\n\n\n\n\n\nRSSI Module\n\n\nLocalization Class\n\n\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n#!/usr/bin/env python\n\n\n# RSSI_Localizer\n\n    \n# Use:\n\n        \n# from rssi import RSSI_Localizer\n\n        \n# rssi_localizer_instance = RSSI_Localizer()\n\n    \n# -------------------------------------------------------\n\n    \n# Description:\n\n        \n# This class helps a user implement rssi-based localization.\n\n        \n# The algorithm assumes the logarithmic distance-path-loss model\n\n        \n# And assumes a minimum of 3 (or more) access points.\n\n    \n# -------------------------------------------------------\n\n    \n# Input:\n\n        \n# accessPoints: Array holding accessPoint dictionaries.\n\n        \n#               The order of the arrays supplied will retain\n\n        \n#               its order, throughout the entire execution.\n\n        \n# [{\n\n        \n#     \nsignalAttenuation\n: 3, \n\n        \n#     \nlocation\n: {\n\n        \n#         \ny\n: 1, \n\n        \n#         \nx\n: 1\n\n        \n#     }, \n\n        \n#     \nreference\n: {\n\n        \n#         \ndistance\n: 4, \n\n        \n#         \nsignal\n: -50\n\n        \n#     }, \n\n        \n#     \nname\n: \ndd-wrt\n\n        \n# },\n\n        \n# {\n\n        \n#     \nsignalAttenuation\n: 4, \n\n        \n#     \nlocation\n: {\n\n        \n#         \ny\n: 1, \n\n        \n#         \nx\n: 7\n\n        \n#     }, \n\n        \n#     \nreference\n: {\n\n        \n#         \ndistance\n: 3, \n\n        \n#         \nsignal\n: -41\n\n        \n#     }, \n\n        \n#     \nname\n: \nucrwpa\n\n        \n# }]\n\n\nclass\n \nRSSI_Localizer\n(\nobject\n):\n\n    \n# Allows us to fetch for networks/accessPoints externally.\n\n    \n# Array of access points must be formatted.\n\n    \n# \nself.count\n parameter is computed internally to aid in \n\n    \n# scaling of the algorithm.\n\n    \ndef\n \n__init__\n(\nself\n,\naccessPoints\n):\n\n        \nself\n.\naccessPoints\n \n=\n \naccessPoints\n\n        \nself\n.\ncount\n \n=\n \nlen\n(\naccessPoints\n)\n\n\n    \n# getDistanceFromAP\n\n        \n# Description:\n\n            \n# Uses the log model to compute an estimated dstance(di) from node(i)\n\n        \n# -------------------------------------------------------\n\n        \n# Input: \n\n            \n# accessPoint: dicitonary holding accesspoint info.\n\n            \n# {\n\n            \n#     \nsignalAttenuation\n: 3, \n\n            \n#     \nlocation\n: {\n\n            \n#         \ny\n: 1, \n\n            \n#         \nx\n: 1\n\n            \n#     }, \n\n            \n#     \nreference\n: {\n\n            \n#         \ndistance\n: 4, \n\n            \n#         \nsignal\n: -50\n\n            \n#     }, \n\n            \n#     \nname\n: \ndd-wrt\n\n            \n# }\n\n            \n# signalStrength: -69\n\n        \n# -------------------------------------------------------\n\n        \n# output: \n\n            \n# accessPoint: dicitonary holding accesspoint info.\n\n            \n# {\n\n            \n#     \nsignalAttenuation\n: 3, \n\n            \n#     \nlocation\n: {\n\n            \n#         \ny\n: 1, \n\n            \n#         \nx\n: 1\n\n            \n#     }, \n\n            \n#     \nreference\n: {\n\n            \n#         \ndistance\n: 4, \n\n            \n#         \nsignal\n: -50\n\n            \n#     }, \n\n            \n#     \nname\n: \ndd-wrt\n\n            \n# }\n\n            \n# signalStrength: -69,\n\n            \n# distance: 2\n\n    \n@staticmethod\n\n    \ndef\n \ngetDistanceFromAP\n(\naccessPoint\n,\n \nsignalStrength\n):\n\n        \nbeta_numerator\n \n=\n \nfloat\n(\naccessPoint\n[\nreference\n][\nsignal\n]\n-\nsignalStrength\n)\n\n        \nbeta_denominator\n \n=\n \nfloat\n(\n10\n*\naccessPoint\n[\nsignalAttenuation\n])\n\n        \nbeta\n \n=\n \nbeta_numerator\n/\nbeta_denominator\n\n        \ndistanceFromAP\n \n=\n \nround\n(((\n10\n**\nbeta\n)\n*\naccessPoint\n[\nreference\n][\ndistance\n]),\n4\n)\n\n        \naccessPoint\n.\nupdate\n({\ndistance\n:\ndistanceFromAP\n})\n\n        \nreturn\n \naccessPoint\n\n\n    \n# TODO fix this because theres two consecutive for loops. \n\n    \n# One that runs to fefd signal strengths to this function, \n\n    \n# a second consecutive loop inside the function.\n\n\n    \n# getDistancesForAllAPs\n\n        \n# Description:\n\n            \n# Makes use of \ngetDistanceFromAP\n to iterate through all \n\n            \n# accesspoints being used in localization and obtains the \n\n            \n# distance from each one of them.\n\n        \n# ------------------------------------------------\n\n        \n# Input:\n\n            \n# signalStrengths:\n\n            \n# [siganl1, siganl2, siganl3]\n\n            \n# [-42, -53, -77]\n\n        \n# ------------------------------------------------\n\n        \n# Output:\n\n            \n# [\n\n            \n#     {\n\n            \n#         \ndistance\n: 4,\n\n            \n#         \nx\n: 2,\n\n            \n#         \ny\n: 3\n\n            \n#     },\n\n            \n#     {\n\n            \n#         \ndistance\n: 7,\n\n            \n#         \nx\n: 2,\n\n            \n#         \ny\n: 5\n\n            \n#     },\n\n            \n#     {\n\n            \n#         \ndistance\n: 9,\n\n            \n#         \nx\n: 7,\n\n            \n#         \ny\n: 3\n\n            \n#     }\n\n            \n# ]\n\n    \ndef\n \ngetDistancesForAllAPs\n(\nself\n,\n \nsignalStrengths\n):\n\n        \napNodes\n \n=\n \n[]\n\n        \nfor\n \ni\n \nin\n \nrange\n(\nlen\n(\nself\n.\naccessPoints\n)):\n\n            \nap\n \n=\n \nself\n.\naccessPoints\n[\ni\n]\n \n            \ndistanceFromAP\n \n=\n \nself\n.\ngetDistanceFromAP\n(\n\n                \nap\n,\n\n                \nsignalStrengths\n[\ni\n]\n\n            \n)\n\n            \napNodes\n.\nappend\n({\n\n                \ndistance\n:\n \ndistanceFromAP\n[\ndistance\n],\n\n                \nx\n:\n \nap\n[\nlocation\n][\nx\n],\n\n                \ny\n:\n \nap\n[\nlocation\n][\ny\n]\n\n            \n})\n\n        \nreturn\n \napNodes\n\n\n    \n# createMatrices\n\n        \n# Description:\n\n            \n# Creates tehmatrices neccesary to use the least squares method\n\n            \n# in order to mnimize the error (error=|realDistance-estimatedDistance|). \n\n            \n# Assuming \nn\n number of nodes and d(m) is the distance(d) from node (m).\n\n            \n# AX = B, where X is our estimated location.\n\n            \n# A = [\n\n            \n#     2(x(i)-xn)    2(y(i)-yn)\n\n            \n#     2(x(i+1)-xn)  2(y(i+1)-yn)\n\n            \n#     ...           ...\n\n            \n#     2(x(n-1)-xn)  2(y(n-1)-yn)\n\n            \n# ]\n\n            \n# B = [\n\n            \n#     x(i)^2 + y(i)^2 - x(n)^2 + y(n)^2 - d(i)^2 + d(n)^2\n\n            \n#     x(i+1)^2 + y(i+1)^2 - x(n)^2 + y(n)^2 - d(i+1)^2 + d(n)^2\n\n            \n#     ...\n\n            \n#     x(n-1)^2 + y(n-1)^2 - x(n)^2 + y(n)^2 - d(n-1)^2 + d(n)^2\n\n            \n# ]\n\n        \n# ----------------------------------------\n\n        \n# Input:\n\n            \n# accessPoints\n\n            \n# [\n\n            \n#     {\n\n            \n#         \ndistance\n: 4,\n\n            \n#         \nx\n: 2,\n\n            \n#         \ny\n: 3\n\n            \n#     },\n\n            \n#     {\n\n            \n#         \ndistance\n: 7,\n\n            \n#         \nx\n: 2,\n\n            \n#         \ny\n: 5\n\n            \n#     },\n\n            \n#     {\n\n            \n#         \ndistance\n: 9,\n\n            \n#         \nx\n: 7,\n\n            \n#         \ny\n: 3\n\n            \n#     }\n\n            \n# ]\n\n        \n# ----------------------------------------\n\n        \n# Output:\n\n            \n# A = [\n\n            \n#     2(2-7)    2(3-3)\n\n            \n#     2(2-7)  2(5-3)\n\n            \n# ]\n\n            \n# B = [\n\n            \n#     2^2 + 3^2 - 7^2 + 3^2 - 4^2 + 9^2\n\n            \n#     2^2 + 5^2 - 7^2 + 3^2 - 7^2 + 9^2\n\n            \n# ]\n\n    \ndef\n \ncreateMatrices\n(\nself\n,\n \naccessPoints\n):\n\n        \n# Sets up that te matrics only go as far as \nn-1\n rows,\n\n        \n# with \nn being the # of access points being used.\n\n        \nn_count\n \n=\n \nself\n.\ncount\n-\n1\n\n        \n# initialize \nA\n matrix with \nn-1\n ranodm rows.\n\n        \na\n \n=\n \nnumpy\n.\nempty\n((\nn_count\n,\n2\n))\n\n        \n# initialize \nB\n matrix with \nn-1\n ranodm rows.\n\n        \nb\n \n=\n \nnumpy\n.\nempty\n((\nn_count\n,\n1\n))\n\n        \n# Define \nx(n)\n (x of last accesspoint)\n\n        \nx_n\n \n=\n \naccessPoints\n[\nn_count\n][\nx\n]\n \n        \n# Define \ny(n)\n (y of last accesspoint)\n\n        \ny_n\n \n=\n \naccessPoints\n[\nn_count\n][\ny\n]\n\n        \n# Define \nd(n)\n (distance from of last accesspoint)\n\n        \nd_n\n \n=\n \naccessPoints\n[\nn_count\n][\ndistance\n]\n\n        \n# Iteration through accesspoints is done upto \nn-1\n only\n\n        \nfor\n \ni\n \nin\n \nrange\n(\nn_count\n):\n\n            \nap\n \n=\n \naccessPoints\n[\ni\n]\n\n            \nx\n,\n \ny\n,\n \nd\n \n=\n \nap\n[\nx\n],\n \nap\n[\ny\n],\n \nap\n[\ndistance\n]\n\n            \na\n[\ni\n]\n \n=\n \n[\n2\n*\n(\nx\n-\nx_n\n),\n \n2\n*\n(\ny\n-\ny_n\n)]\n\n            \nb\n[\ni\n]\n \n=\n \n[(\nx\n**\n2\n)\n+\n(\ny\n**\n2\n)\n-\n(\nx_n\n**\n2\n)\n-\n(\ny_n\n**\n2\n)\n-\n(\nd\n**\n2\n)\n+\n(\nd_n\n**\n2\n)]\n\n        \nreturn\n \na\n,\n \nb\n\n\n    \n# computePosition\n\n        \n# Description:\n\n            \n# Performs the \nleast squares method\n matrix operations \n\n            \n# neccessary to get the \nx\n and \ny\n of the unknown \n\n            \n# beacon\ns position.\n\n            \n# X = [(A_transposed*A)^-1]*[A_transposed*B]\n\n        \n# ----------------------------------------\n\n        \n# Input:\n\n            \n# A = [\n\n            \n#     0   0\n\n            \n#     0  -4\n\n            \n# ]\n\n            \n# B = [\n\n            \n#     4 + 9 - 49 + 9 - 16 + 81  =\n 38\n\n            \n#     4 + 25 - 49 + 9 - 49 + 81 =\n 21\n\n            \n# ]\n\n        \n# ----------------------------------------\n\n        \n# Output:\n\n            \n# x\n\n            \n# [\n\n            \n#     2,\n\n            \n#     3\n\n            \n# ]\n\n    \n@staticmethod\n\n    \ndef\n \ncomputePosition\n(\na\n,\n \nb\n):\n\n        \n# Get \nA_transposed\n matrix\n\n        \nat\n \n=\n \nnumpy\n.\ntranspose\n(\na\n)\n\n        \n# Get \nA_transposed*A\n matrix\n\n        \nat_a\n \n=\n \nnumpy\n.\nmatmul\n(\nat\n,\na\n)\n\n        \n# Get \n[(A_transposed*A)^-1]\n matrix\n\n        \ninv_at_a\n \n=\n \nnumpy\n.\nlinalg\n.\ninv\n(\nat_a\n)\n\n        \n# Get \n[A_transposed*B]\n\n        \nat_b\n \n=\n \nnumpy\n.\nmatmul\n(\nat\n,\nb\n)\n\n        \n# Get \n[(A_transposed*A)^-1]*[A_transposed*B]\n\n        \n# This holds our position (xn,yn)\n\n        \nx\n \n=\n \nnumpy\n.\nmatmul\n(\ninv_at_a\n,\nat_b\n)\n \n        \nreturn\n \nx\n\n\n    \n# getNodePosition\n\n        \n# Description:\n\n            \n# Combines \ngetDistancesForAllAPs\n, \ncreateMatrics\n,\n\n            \n# and \ncomputerPosition\n to get the \nX\n vector that\n\n            \n# contains our unkown (x,y) position.\n\n        \n# ----------------------------------------\n\n        \n# Input:\n\n            \n# signalStrengths\n\n            \n# [4, 2 , 3]\n\n        \n# ----------------------------------------\n\n        \n# Output:\n\n            \n# x\n\n            \n# [2, 3]\n\n    \ndef\n \ngetNodePosition\n(\nself\n,\n \nsignalStrengths\n):\n\n        \napNodes\n \n=\n \nself\n.\ngetDistancesForAllAPs\n(\nsignalStrengths\n)\n\n        \na\n,\n \nb\n \n=\n \nself\n.\ncreateMatrices\n(\napNodes\n)\n \n        \nposition\n \n=\n \nself\n.\ncomputePosition\n(\na\n,\n \nb\n)\n\n        \n# print(a)\n\n        \n# print(b)\n\n        \nreturn\n \nposition\n\n\n\n\n\n\n\nROS Wrapper\n\n\nRSSI Node\n\n\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n#!/usr/bin/env python\n\n\nimport\n \nrospy\n \n#import ROS pip package for using ROS library\n\n\nfrom\n \nomnibot.msg\n \nimport\n \nMotorArray\n \n# import our custom ROS msg types\n\n\nfrom\n \nrssi\n \nimport\n \nRSSI_Scan\n \n#Imports the RSSI_scan class from the sibling rssi file\n\n\nfrom\n \nrssi\n \nimport\n \nRSSI_Localizer\n\n\n\n# getNetworks:\n\n    \n# Description:\n\n        \n# Parses the \naccessPoints\n portion of the rosparams\n\n        \n# dictionary, and returns a list of network dictioanries,\n\n        \n# in order. Order specified in yaml params file and.\n\n        \n# remains persistent.\n\n    \n# --------------------------------------------------\n\n    \n# Input:\n\n        \n# {\n\n        \n#     \nap1\n: {\n\n        \n#         \nsignalAttenuation\n: 3, \n\n        \n#         \nlocation\n: {\n\n        \n#             \ny\n: 7, \n\n        \n#             \nx\n: 1\n\n        \n#         }, \n\n        \n#         \nreference\n: {\n\n        \n#             \ndistance\n: 5, \n\n        \n#             \nsignal\n: 60\n\n        \n#         }, \n\n        \n#         \nname\n: \n\n        \n#         \ndd-wrt\n\n        \n#     }, \n\n        \n#     \nap2\n: {\n\n        \n#         \nname\n: \nOnePlus3\n, \n\n        \n#         \nlocation\n: {\n\n        \n#             \ny\n: 11, \n\n        \n#             \nx\n: 3\n\n        \n#         },\n\n        \n#         \nreference\n: {\n\n        \n#             \ndistance\n: 4, \n\n        \n#             \nsignal\n: 40\n\n        \n#         }, \n\n        \n#         \nsignalAttenuation\n: 3\n\n        \n#     },\n\n        \n# }\n\n    \n# ------------------------------------------------\n\n    \n# Returns: (networkNames,accessPoints)\n\n        \n# networkNames =\n [\n\n        \n#   \ndd-wrt\n,\n\n        \n#   \nOnePlus3\n\n        \n# ]\n\n        \n# accessPoints =\n Ordered list of dictionaries.\n\n        \n# [\n\n        \n#     {\n\n        \n#         \nsignalAttenuation\n: 3, \n\n        \n#         \nlocation\n: {\n\n        \n#             \ny\n: 7, \n\n        \n#             \nx\n: 1\n\n        \n#         }, \n\n        \n#         \nreference\n: {\n\n        \n#             \ndistance\n: 5, \n\n        \n#             \nsignal\n: 60\n\n        \n#         }, \n\n        \n#         \nname\n: \ndd-wrt\n\n        \n#     }, \n\n        \n#     {\n\n        \n#         \nname\n: \nOnePlus3\n, \n\n        \n#         \nlocation\n: {\n\n        \n#             \ny\n: 11, \n\n        \n#             \nx\n: 3\n\n        \n#         },\n\n        \n#         \nreference\n: {\n\n        \n#             \ndistance\n: 4, \n\n        \n#             \nsignal\n: 40\n\n        \n#         }, \n\n        \n#         \nsignalAttenuation\n: 3\n\n        \n#     }\n\n        \n# ]\n\n\ndef\n \ngetNetworks\n(\naccessPointDict\n):\n\n    \naccessPointKeys\n \n=\n \naccessPointDict\n.\nkeys\n()\n\n    \naccessPointKeys\n.\nsort\n()\n\n    \nnetworkNames\n \n=\n \n[]\n\n    \naccessPoints\n \n=\n \n[]\n\n    \nfor\n \nkey\n \nin\n \naccessPointKeys\n:\n\n        \naccessPoints\n.\nappend\n(\naccessPointDict\n[\nkey\n])\n\n        \nnetworkNames\n.\nappend\n(\naccessPointDict\n[\nkey\n][\nname\n])\n\n\n    \nreturn\n \nnetworkNames\n,\naccessPoints\n\n\n\ndef\n \nrssiPublisher\n():\n\n    \n# Single call to the parameter server\n\n    \nrosParams\n \n=\n \nrospy\n.\nget_param\n(\nrssi\n)\n\n        \n# {\n\n        \n#     \naccessPoints\n: {\n\n        \n#         \nap1\n: {\n\n        \n#             \nsignalAttenuation\n: 3, \n\n        \n#             \nlocation\n: {\n\n        \n#                 \ny\n: 7, \n\n        \n#                 \nx\n: 1\n\n        \n#             }, \n\n        \n#             \nreference\n: {\n\n        \n#                 \ndistance\n: 5, \n\n        \n#                 \nsignal\n: 60\n\n        \n#             }, \n\n        \n#             \nname\n: \n\n        \n#             \ndd-wrt\n\n        \n#         }, \n\n        \n#         \nap2\n: {\n\n        \n#             \nname\n: \nOnePlus3\n, \n\n        \n#             \nlocation\n: {\n\n        \n#                 \ny\n: 11, \n\n        \n#                 \nx\n: 3\n\n        \n#             },\n\n        \n#             \nreference\n: {\n\n        \n#                 \ndistance\n: 4, \n\n        \n#                 \nsignal\n: 40\n\n        \n#             }, \n\n        \n#             \nsignalAttenuation\n: 3\n\n        \n#         },\n\n        \n#     }\n\n        \n#     \nnetworkInterface\n: \nwlp1s0\n\n        \n# }\n\n\n    \npub\n \n=\n \nrospy\n.\nPublisher\n(\nrssiLocalization_topic\n,\n \nMotorArray\n,\n \nqueue_size\n=\n10\n)\n\n    \n# Get parameters from our ROS server\n\n    \nnetworkInterface\n \n=\n \nrosParams\n[\nnetworkInterface\n]\n\n    \nssids\n,\nnetworks\n \n=\n \ngetNetworks\n(\nrosParams\n[\naccessPoints\n])\n\n    \n# Initialize node\n\n    \nrospy\n.\ninit_node\n(\nrssiPublisher_node\n)\n\n    \n# Create instance of RSSI module.\n\n    \n# This makes our \ngetAccessPoints\n function available to us.\n\n    \nrssi\n \n=\n \nRSSI_Scan\n(\nnetworkInterface\n)\n\n    \nlocalizer\n \n=\n \nRSSI_Localizer\n(\nnetworks\n)\n\n    \n# This keeps the node running until the script is shut down manually.\n\n    \n# node will keep cycling at the frequncy set above.\n\n    \nwhile\n \nnot\n \nrospy\n.\nis_shutdown\n():\n \n        \n# Returns an array of all access-points of interest (if they are in range).\n\n        \n# Process takes about 1.5-4 seconds to finish.\n\n        \nap_info\n \n=\n \nrssi\n.\ngetAPinfo\n(\nnetworks\n=\nssids\n,\n \nsudo\n=\nTrue\n)\n\n        \n# rospy.loginfo(ap_info)\n\n        \nrssi_values\n \n=\n \n[\nap\n[\nsignal\n]\n \nfor\n \nap\n \nin\n \nap_info\n]\n\n        \nrospy\n.\nloginfo\n(\nrssi_values\n)\n\n        \ndistances\n \n=\n \nlocalizer\n.\ngetDistancesForAllAPs\n(\nrssi_values\n)\n\n        \ndistances\n \n=\n \n[\ndistance\n[\ndistance\n]\n \nfor\n \ndistance\n \nin\n \ndistances\n]\n\n        \nrospy\n.\nloginfo\n(\ndistances\n)\n\n        \nposition\n \n=\n \nlocalizer\n.\ngetNodePosition\n(\nrssi_values\n)\n\n        \n# if len(ap_info)\n2:\n\n        \n#     continue\n\n        \n# rospy.loginfo(rssi_values)\n\n        \nrospy\n.\nloginfo\n(\nposition\n)\n\n\n        \n# pub.publish(aps[0][\nsignal\n],aps[1][\nsignal\n],0)\n\n\n\nif\n \n__name__\n \n==\n \n__main__\n:\n\n    \ntry\n:\n\n        \nrssiPublisher\n()\n\n    \nexcept\n \nrospy\n.\nROSInterruptException\n:\n\n        \npass", 
            "title": "Wifi Localization"
        }, 
        {
            "location": "/wifiLocalization/#wifi-localization", 
            "text": "RSSI-based self-loclaization is utilized as a substitute for Bluetooth and/or GPS localization.\nOur module was designed entirely around Xiuyan Zhu's and Yuan Feng's 'RSSI-based Algorithm for Indoor Localization' \npaper, published here: https://file.scirp.org/pdf/CN_2013071010352139.pdf  Using the wifi signal detected from three separate access points, we can use the log-model (as described in the paper) \nto estimate our distance from each access point. With a distance estimated fomr each node, we use the trilateral-localization\nalgortihm to estimate a location.  Note: The location of each node must not be fixed, but must be specified.  Log Model\nCS = Current Signal from node x\nRS = Reference Signal for node x\nCD = Current Distance from node x\nRD = Reference Distance for node x\nn = Signal Attenuation Factor\nlog = log w/base-10  [CS] = [RS]-[10*nlog(CD/RD)]  Solving for CD:\n[Beta] = [(RS-CS)/(10 n)]\n[CD] = [10^Beta] [RD]  For more information on the python rssi module, visit: \nhttps://github.com/jvillagomez/rssi_module", 
            "title": "Wifi Localization"
        }, 
        {
            "location": "/wifiLocalization/#rssi-module", 
            "text": "", 
            "title": "RSSI Module"
        }, 
        {
            "location": "/wifiLocalization/#scan-class", 
            "text": "1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313 #!/usr/bin/env python  # RSSI_Scan \n     # Use: \n         # from rssi import RSSI_Scan \n         # rssi_scan_instance = RSSI_Scan( network_interface_name)  \n     # ------------------------------------------------------- \n     # Description: \n         # Allows a user to query all available accesspoints available. \n         # User has the option of define a specific set of access  \n         # points to query. \n     # ------------------------------------------------------- \n     # Input: interface name \n         # [ie. network interface names: wlp1s0m, docker0, wlan0]   class   RSSI_Scan ( object ): \n     # Allows us to declare a network interface externally. \n     def   __init__ ( self ,   interface ): \n         self . interface   =   interface \n\n     # getRawNetworkScan \n         # Description: \n             # Runs the Ubuntu command  iwlist  to scan for available networks. \n             # Returns the raw console window output (unparsed). \n         # ---------------------------------------------------------------- \n         # Input: (optional)  \n             #   sudo: bool; defaults to false. False will not refresh the  \n             #         network interface upon query. Sudo=true will require  \n             #         the user will need to enter a sudo password at runtime. \n         # ---------------------------------------------------------------- \n         # Returns: Raw terminal output \n             # { \n             #      output : wlp1s0    Scan completed : \n             #   Cell 01 - Address: A0:3D:6F:26:77:8E \n             #             Channel:144 \n             #             Frequency:5.72 GHz \n             #             Quality=43/70  Signal level=-67 dBm   \n             #             Encryption key:on \n             #             ESSID: ucrwpa \n             #             Bit Rates:24 Mb/s; 36 Mb/s; 48 Mb/s; 54 Mb/s \n             #             Mode:Master \n             #   Cell 02 - Address: A0:3D:6F:26:77:82 \n             #             Channel:1 \n             #             Frequency:2.412 GHz (Channel 1) \n             #             Quality=43/70  Signal level=-67 dBm   \n             #             Encryption key:on \n             #             ESSID: eduroam \n             #             Bit Rates:18 Mb/s; 24 Mb/s; 36 Mb/s; 48 Mb/s; 54 Mb/s \n             #             Mode:Master , \n             #      error : \n             # } \n     def   getRawNetworkScan ( self ,   sudo = False ): \n         # Scan command  iwlist interface scan  needs to be fed as an array. \n         if   sudo : \n             scan_command   =   [ sudo , iwlist , self . interface , scan ] \n         else : \n             scan_command   =   [ iwlist , self . interface , scan ] \n         # Open a subprocess running the scan command. \n         scan_process   =   Popen ( scan_command ,   stdout = PIPE ,   stderr = PIPE ) \n         # Block all execution, until the scanning completes. \n         scan_process . wait () \n         # Returns the  success  and  error  output. \n         ( raw_output ,   raw_error )   =   scan_process . communicate ()  \n         # Returns all output in a dictionary for easy retrieval. \n         return   { output : raw_output , error : raw_error } \n\n     # getSSID \n         # Description: \n             # Parses the  SSID  for a given cell. \n         # ----------------------------------------------- \n         # Input: (Raw string) \n             # 01 - Address: A0:3D:6F:26:77:8E \n             # Channel:144 \n             # Frequency:5.72 GHz \n             # Quality=43/70  Signal level=-67 dBm   \n             # Encryption key:on \n             # ESSID: ucrwpa \n             # Bit Rates:24 Mb/s; 36 Mb/s; 48 Mb/s; 54 Mb/s \n             # Mode:Master \n         # ----------------------------------------------- \n         # Returns: \n             #  ucrwpa \n     @staticmethod \n     def   getSSID ( raw_cell ): \n         ssid   =   raw_cell . split ( ESSID: )[ 1 ] \n         ssid   =   ssid . split ( )[ 0 ] \n         return   ssid \n\n     # getQuality \n         # Description: \n             # Parses  Quality level  for a given cell. \n         # ----------------------------------------------- \n         # Input: (Raw string) \n             # 01 - Address: A0:3D:6F:26:77:8E \n             # Channel:144 \n             # Frequency:5.72 GHz \n             # Quality=43/70  Signal level=-67 dBm   \n             # Encryption key:on \n             # ESSID: ucrwpa \n             # Bit Rates:24 Mb/s; 36 Mb/s; 48 Mb/s; 54 Mb/s \n             # Mode:Master \n         # ----------------------------------------------- \n         # Returns: \n             #  43/70 \n     @staticmethod \n     def   getQuality ( raw_cell ): \n         quality   =   raw_cell . split ( Quality= )[ 1 ] \n         quality   =   quality . split (   )[ 0 ] \n         return   quality \n\n     # getSignalLevel \n         # Description: \n             # Parses  Signal level  for a given cell. \n             # Measurement is in  dBm . \n         # ----------------------------------------------- \n         # Input: (Raw string) \n             # 01 - Address: A0:3D:6F:26:77:8E \n             # Channel:144 \n             # Frequency:5.72 GHz \n             # Quality=43/70  Signal level=-67 dBm   \n             # Encryption key:on \n             # ESSID: ucrwpa \n             # Bit Rates:24 Mb/s; 36 Mb/s; 48 Mb/s; 54 Mb/s \n             # Mode:Master \n         # ----------------------------------------------- \n         # Returns: (string) \n             #  -67      \n     @staticmethod \n     def   getSignalLevel ( raw_cell ): \n         signal   =   raw_cell . split ( Signal level= )[ 1 ] \n         signal   =   int ( signal . split (   )[ 0 ]) \n         return   signal \n\n     # parseCell \n         # Description: \n             # Takes a raw cell string and parses it into a dictionary. \n         # ----------------------------------------------- \n         # Input: (Raw string) \n             #  01 - Address: A0:3D:6F:26:77:8E \n             # Channel:144 \n             # Frequency:5.72 GHz \n             # Quality=43/70  Signal level=-67 dBm   \n             # Encryption key:on \n             # ESSID: ucrwpa \n             # Bit Rates:24 Mb/s; 36 Mb/s; 48 Mb/s; 54 Mb/s \n             # Mode:Master \n         # ----------------------------------------------- \n         # Returns: \n             # { \n             #      ssid : ucrwpa , \n             #      quality : 43/70 , \n             #      signal : -67 \n             # }     \n     def   parseCell ( self ,   raw_cell ): \n         cell   =   { \n             ssid :   self . getSSID ( raw_cell ), \n             quality :   self . getQuality ( raw_cell ), \n             signal :   self . getSignalLevel ( raw_cell ) \n         } \n         return   cell \n\n     # formatCells \n         # Description: \n             # Every network listed is considered a  cell. \n             # This function parses each cell into a dictionary. \n             # Returns list of dictionaries. Makes use of  parseCell . \n             # If not networks were detected, returns False. \n         # ----------------------------------------------- \n         # Input: (Raw terminal string) \n             #  01 - Address: A0:3D:6F:26:77:8E \n             # Channel:144 \n             # Frequency:5.72 GHz \n             # Quality=43/70  Signal level=-67 dBm   \n             # Encryption key:on \n             # ESSID: ucrwpa \n             # Bit Rates:24 Mb/s; 36 Mb/s; 48 Mb/s; 54 Mb/s \n             # Mode:Master \n             # 02 - Address: A0:3D:6F:26:77:8E \n             # Channel:144 \n             # Frequency:5.72 GHz \n             # Quality=30/70  Signal level=-42 dBm   \n             # Encryption key:on \n             # ESSID: dd-wrt \n             # Bit Rates:24 Mb/s; 36 Mb/s; 48 Mb/s; 54 Mb/s \n             # Mode:Master \n         # ----------------------------------------------- \n         # Returns: (Array of dictionaries) \n             # [ \n             #     { \n             #          ssid : ucrwpa , \n             #          quality : 43/70 , \n             #          signal : -67 \n             #     }, \n             #     { \n             #          ssid : dd-wrt , \n             #          quality : 30/70 , \n             #          signal : -42 \n             #     } \n             # ]     \n     def   formatCells ( self ,   raw_cell_string ): \n         raw_cells   =   raw_cell_string . split ( Cell )   # Divide raw string into raw cells. \n         raw_cells . pop ( 0 )   # Remove unneccesary  Scan Completed  message. \n         if ( len ( raw_cells )     0 ):   # Continue execution, if atleast one network is detected. \n             # Iterate through raw cells for parsing. \n             # Array will hold all parsed cells as dictionaries. \n             formatted_cells   =   [ self . parseCell ( cell )   for   cell   in   raw_cells ] \n             # Return array of dictionaries, containing cells. \n             return   formatted_cells \n         else : \n             print ( Networks not detected. ) \n             return   False \n         # TODO implement function in ndoe to process this boolean (False) \n\n     # filterAccessPoints \n         # Description: \n             # If the  networks  parameter is passed to the  getAPinfo \n             # function, then this method will filter out all irrelevant  \n             # access-points. Access points specified in  networks  array  \n             # will be returned (if available). \n         # ----------------------------------------------- \n         # Input: (Parsed array of cell dictionaries) \n             # all_access_points =  \n             # [ \n             #     { \n             #          ssid : ucrwpa , \n             #          quality : 43/70 , \n             #          signal : -67 \n             #     }, \n             #     { \n             #          ssid : dd-wrt , \n             #          quality : 30/70 , \n             #          signal : -42 \n             #     }, \n             #     { \n             #          ssid : linksys , \n             #          quality : 58/70 , \n             #          signal : -24 \n             #     } \n             # ]  \n             # network_names = (array of network names) \n             # [ ucrwpa , dd-wrt ] \n         # ----------------------------------------------- \n         # Returns: (Array of dictionaries) \n             # [ \n             #     { \n             #          ssid : ucrwpa , \n             #          quality : 43/70 , \n             #          signal : -67 \n             #     }, \n             #     { \n             #          ssid : dd-wrt , \n             #          quality : 30/70 , \n             #          signal : -42 \n             #     } \n             # ]  \n     @staticmethod \n     def   filterAccessPoints ( all_access_points ,   network_names ): \n         focus_points   =   []   # Array holding the access-points of concern. \n         # Iterate throguh all access-points found. \n         for   point   in   all_access_points : \n             # Check if current AP is in our desired list. \n             if   point [ ssid ]   in   network_names : \n                 focus_points . append ( point ) \n         return   focus_points \n         # TODO implement something incase our desired ones were not found \n\n     # getAPinfo \n         # Description: \n             # Method returns all (or chosen) available access points (in range). \n             # Takes 2 optional parameters:  \n             #    networks  (array):  \n             #       Lists all ssid s of concern. Will return only the available access  \n             #       points listed here. If not provided, will return ALL access-points in range.         \n             #    sudo  (bool):  \n             #       Whether of not method should use sudo privileges. If user uses sudo \n             #       privileges, the network manager will be refreshed and will return  \n             #       a fresh list of access-points available. If sudo is not provided,  \n             #       a cached list will be returned. Cached list gets updated periodically. \n         # ----------------------------------------------- \n         # Input: (Parsed array of cell dictionaries) \n             # networks = (array of network names) \n             # [ ucrwpa , dd-wrt ] \n             # sudo = True || False \n         # ----------------------------------------------- \n         # Returns: (Array of dictionaries) \n             # [ \n             #     { \n             #          ssid : ucrwpa , \n             #          quality : 43/70 , \n             #          signal : -67 \n             #     }, \n             #     { \n             #          ssid : dd-wrt , \n             #          quality : 30/70 , \n             #          signal : -42 \n             #     } \n             # ]  \n     def   getAPinfo ( self ,   networks = False ,   sudo = False ): \n         # TODO implement error callback if error is raise in subprocess \n         # Unparsed access-point listing. AccessPoints are strings. \n         raw_scan_output   =   self . getRawNetworkScan ( sudo )[ output ]  \n         # Parsed access-point listing. Access-points are dictionaries. \n         all_access_points   =   self . formatCells ( raw_scan_output ) \n         # Checks if access-points were found. \n         if   all_access_points : \n             # Checks if specific networks were declared. \n             if   networks : \n                 # Return specific access-points found. \n                 return   self . filterAccessPoints ( all_access_points ,   networks ) \n             else : \n                 # Return ALL access-points found. \n                 return   all_access_points \n         else : \n             # No access-points were found.  \n             return   False", 
            "title": "Scan Class"
        }, 
        {
            "location": "/wifiLocalization/#rssi-module_1", 
            "text": "", 
            "title": "RSSI Module"
        }, 
        {
            "location": "/wifiLocalization/#localization-class", 
            "text": "1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269 #!/usr/bin/env python  # RSSI_Localizer \n     # Use: \n         # from rssi import RSSI_Localizer \n         # rssi_localizer_instance = RSSI_Localizer() \n     # ------------------------------------------------------- \n     # Description: \n         # This class helps a user implement rssi-based localization. \n         # The algorithm assumes the logarithmic distance-path-loss model \n         # And assumes a minimum of 3 (or more) access points. \n     # ------------------------------------------------------- \n     # Input: \n         # accessPoints: Array holding accessPoint dictionaries. \n         #               The order of the arrays supplied will retain \n         #               its order, throughout the entire execution. \n         # [{ \n         #      signalAttenuation : 3,  \n         #      location : { \n         #          y : 1,  \n         #          x : 1 \n         #     },  \n         #      reference : { \n         #          distance : 4,  \n         #          signal : -50 \n         #     },  \n         #      name :  dd-wrt \n         # }, \n         # { \n         #      signalAttenuation : 4,  \n         #      location : { \n         #          y : 1,  \n         #          x : 7 \n         #     },  \n         #      reference : { \n         #          distance : 3,  \n         #          signal : -41 \n         #     },  \n         #      name :  ucrwpa \n         # }]  class   RSSI_Localizer ( object ): \n     # Allows us to fetch for networks/accessPoints externally. \n     # Array of access points must be formatted. \n     #  self.count  parameter is computed internally to aid in  \n     # scaling of the algorithm. \n     def   __init__ ( self , accessPoints ): \n         self . accessPoints   =   accessPoints \n         self . count   =   len ( accessPoints ) \n\n     # getDistanceFromAP \n         # Description: \n             # Uses the log model to compute an estimated dstance(di) from node(i) \n         # ------------------------------------------------------- \n         # Input:  \n             # accessPoint: dicitonary holding accesspoint info. \n             # { \n             #      signalAttenuation : 3,  \n             #      location : { \n             #          y : 1,  \n             #          x : 1 \n             #     },  \n             #      reference : { \n             #          distance : 4,  \n             #          signal : -50 \n             #     },  \n             #      name :  dd-wrt \n             # } \n             # signalStrength: -69 \n         # ------------------------------------------------------- \n         # output:  \n             # accessPoint: dicitonary holding accesspoint info. \n             # { \n             #      signalAttenuation : 3,  \n             #      location : { \n             #          y : 1,  \n             #          x : 1 \n             #     },  \n             #      reference : { \n             #          distance : 4,  \n             #          signal : -50 \n             #     },  \n             #      name :  dd-wrt \n             # } \n             # signalStrength: -69, \n             # distance: 2 \n     @staticmethod \n     def   getDistanceFromAP ( accessPoint ,   signalStrength ): \n         beta_numerator   =   float ( accessPoint [ reference ][ signal ] - signalStrength ) \n         beta_denominator   =   float ( 10 * accessPoint [ signalAttenuation ]) \n         beta   =   beta_numerator / beta_denominator \n         distanceFromAP   =   round ((( 10 ** beta ) * accessPoint [ reference ][ distance ]), 4 ) \n         accessPoint . update ({ distance : distanceFromAP }) \n         return   accessPoint \n\n     # TODO fix this because theres two consecutive for loops.  \n     # One that runs to fefd signal strengths to this function,  \n     # a second consecutive loop inside the function. \n\n     # getDistancesForAllAPs \n         # Description: \n             # Makes use of  getDistanceFromAP  to iterate through all  \n             # accesspoints being used in localization and obtains the  \n             # distance from each one of them. \n         # ------------------------------------------------ \n         # Input: \n             # signalStrengths: \n             # [siganl1, siganl2, siganl3] \n             # [-42, -53, -77] \n         # ------------------------------------------------ \n         # Output: \n             # [ \n             #     { \n             #          distance : 4, \n             #          x : 2, \n             #          y : 3 \n             #     }, \n             #     { \n             #          distance : 7, \n             #          x : 2, \n             #          y : 5 \n             #     }, \n             #     { \n             #          distance : 9, \n             #          x : 7, \n             #          y : 3 \n             #     } \n             # ] \n     def   getDistancesForAllAPs ( self ,   signalStrengths ): \n         apNodes   =   [] \n         for   i   in   range ( len ( self . accessPoints )): \n             ap   =   self . accessPoints [ i ]  \n             distanceFromAP   =   self . getDistanceFromAP ( \n                 ap , \n                 signalStrengths [ i ] \n             ) \n             apNodes . append ({ \n                 distance :   distanceFromAP [ distance ], \n                 x :   ap [ location ][ x ], \n                 y :   ap [ location ][ y ] \n             }) \n         return   apNodes \n\n     # createMatrices \n         # Description: \n             # Creates tehmatrices neccesary to use the least squares method \n             # in order to mnimize the error (error=|realDistance-estimatedDistance|).  \n             # Assuming  n  number of nodes and d(m) is the distance(d) from node (m). \n             # AX = B, where X is our estimated location. \n             # A = [ \n             #     2(x(i)-xn)    2(y(i)-yn) \n             #     2(x(i+1)-xn)  2(y(i+1)-yn) \n             #     ...           ... \n             #     2(x(n-1)-xn)  2(y(n-1)-yn) \n             # ] \n             # B = [ \n             #     x(i)^2 + y(i)^2 - x(n)^2 + y(n)^2 - d(i)^2 + d(n)^2 \n             #     x(i+1)^2 + y(i+1)^2 - x(n)^2 + y(n)^2 - d(i+1)^2 + d(n)^2 \n             #     ... \n             #     x(n-1)^2 + y(n-1)^2 - x(n)^2 + y(n)^2 - d(n-1)^2 + d(n)^2 \n             # ] \n         # ---------------------------------------- \n         # Input: \n             # accessPoints \n             # [ \n             #     { \n             #          distance : 4, \n             #          x : 2, \n             #          y : 3 \n             #     }, \n             #     { \n             #          distance : 7, \n             #          x : 2, \n             #          y : 5 \n             #     }, \n             #     { \n             #          distance : 9, \n             #          x : 7, \n             #          y : 3 \n             #     } \n             # ] \n         # ---------------------------------------- \n         # Output: \n             # A = [ \n             #     2(2-7)    2(3-3) \n             #     2(2-7)  2(5-3) \n             # ] \n             # B = [ \n             #     2^2 + 3^2 - 7^2 + 3^2 - 4^2 + 9^2 \n             #     2^2 + 5^2 - 7^2 + 3^2 - 7^2 + 9^2 \n             # ] \n     def   createMatrices ( self ,   accessPoints ): \n         # Sets up that te matrics only go as far as  n-1  rows, \n         # with  n being the # of access points being used. \n         n_count   =   self . count - 1 \n         # initialize  A  matrix with  n-1  ranodm rows. \n         a   =   numpy . empty (( n_count , 2 )) \n         # initialize  B  matrix with  n-1  ranodm rows. \n         b   =   numpy . empty (( n_count , 1 )) \n         # Define  x(n)  (x of last accesspoint) \n         x_n   =   accessPoints [ n_count ][ x ]  \n         # Define  y(n)  (y of last accesspoint) \n         y_n   =   accessPoints [ n_count ][ y ] \n         # Define  d(n)  (distance from of last accesspoint) \n         d_n   =   accessPoints [ n_count ][ distance ] \n         # Iteration through accesspoints is done upto  n-1  only \n         for   i   in   range ( n_count ): \n             ap   =   accessPoints [ i ] \n             x ,   y ,   d   =   ap [ x ],   ap [ y ],   ap [ distance ] \n             a [ i ]   =   [ 2 * ( x - x_n ),   2 * ( y - y_n )] \n             b [ i ]   =   [( x ** 2 ) + ( y ** 2 ) - ( x_n ** 2 ) - ( y_n ** 2 ) - ( d ** 2 ) + ( d_n ** 2 )] \n         return   a ,   b \n\n     # computePosition \n         # Description: \n             # Performs the  least squares method  matrix operations  \n             # neccessary to get the  x  and  y  of the unknown  \n             # beacon s position. \n             # X = [(A_transposed*A)^-1]*[A_transposed*B] \n         # ---------------------------------------- \n         # Input: \n             # A = [ \n             #     0   0 \n             #     0  -4 \n             # ] \n             # B = [ \n             #     4 + 9 - 49 + 9 - 16 + 81  =  38 \n             #     4 + 25 - 49 + 9 - 49 + 81 =  21 \n             # ] \n         # ---------------------------------------- \n         # Output: \n             # x \n             # [ \n             #     2, \n             #     3 \n             # ] \n     @staticmethod \n     def   computePosition ( a ,   b ): \n         # Get  A_transposed  matrix \n         at   =   numpy . transpose ( a ) \n         # Get  A_transposed*A  matrix \n         at_a   =   numpy . matmul ( at , a ) \n         # Get  [(A_transposed*A)^-1]  matrix \n         inv_at_a   =   numpy . linalg . inv ( at_a ) \n         # Get  [A_transposed*B] \n         at_b   =   numpy . matmul ( at , b ) \n         # Get  [(A_transposed*A)^-1]*[A_transposed*B] \n         # This holds our position (xn,yn) \n         x   =   numpy . matmul ( inv_at_a , at_b )  \n         return   x \n\n     # getNodePosition \n         # Description: \n             # Combines  getDistancesForAllAPs ,  createMatrics , \n             # and  computerPosition  to get the  X  vector that \n             # contains our unkown (x,y) position. \n         # ---------------------------------------- \n         # Input: \n             # signalStrengths \n             # [4, 2 , 3] \n         # ---------------------------------------- \n         # Output: \n             # x \n             # [2, 3] \n     def   getNodePosition ( self ,   signalStrengths ): \n         apNodes   =   self . getDistancesForAllAPs ( signalStrengths ) \n         a ,   b   =   self . createMatrices ( apNodes )  \n         position   =   self . computePosition ( a ,   b ) \n         # print(a) \n         # print(b) \n         return   position", 
            "title": "Localization Class"
        }, 
        {
            "location": "/wifiLocalization/#ros-wrapper", 
            "text": "", 
            "title": "ROS Wrapper"
        }, 
        {
            "location": "/wifiLocalization/#rssi-node", 
            "text": "1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154 #!/usr/bin/env python  import   rospy   #import ROS pip package for using ROS library  from   omnibot.msg   import   MotorArray   # import our custom ROS msg types  from   rssi   import   RSSI_Scan   #Imports the RSSI_scan class from the sibling rssi file  from   rssi   import   RSSI_Localizer  # getNetworks: \n     # Description: \n         # Parses the  accessPoints  portion of the rosparams \n         # dictionary, and returns a list of network dictioanries, \n         # in order. Order specified in yaml params file and. \n         # remains persistent. \n     # -------------------------------------------------- \n     # Input: \n         # { \n         #      ap1 : { \n         #          signalAttenuation : 3,  \n         #          location : { \n         #              y : 7,  \n         #              x : 1 \n         #         },  \n         #          reference : { \n         #              distance : 5,  \n         #              signal : 60 \n         #         },  \n         #          name :  \n         #          dd-wrt \n         #     },  \n         #      ap2 : { \n         #          name :  OnePlus3 ,  \n         #          location : { \n         #              y : 11,  \n         #              x : 3 \n         #         }, \n         #          reference : { \n         #              distance : 4,  \n         #              signal : 40 \n         #         },  \n         #          signalAttenuation : 3 \n         #     }, \n         # } \n     # ------------------------------------------------ \n     # Returns: (networkNames,accessPoints) \n         # networkNames =  [ \n         #    dd-wrt , \n         #    OnePlus3 \n         # ] \n         # accessPoints =  Ordered list of dictionaries. \n         # [ \n         #     { \n         #          signalAttenuation : 3,  \n         #          location : { \n         #              y : 7,  \n         #              x : 1 \n         #         },  \n         #          reference : { \n         #              distance : 5,  \n         #              signal : 60 \n         #         },  \n         #          name :  dd-wrt \n         #     },  \n         #     { \n         #          name :  OnePlus3 ,  \n         #          location : { \n         #              y : 11,  \n         #              x : 3 \n         #         }, \n         #          reference : { \n         #              distance : 4,  \n         #              signal : 40 \n         #         },  \n         #          signalAttenuation : 3 \n         #     } \n         # ]  def   getNetworks ( accessPointDict ): \n     accessPointKeys   =   accessPointDict . keys () \n     accessPointKeys . sort () \n     networkNames   =   [] \n     accessPoints   =   [] \n     for   key   in   accessPointKeys : \n         accessPoints . append ( accessPointDict [ key ]) \n         networkNames . append ( accessPointDict [ key ][ name ]) \n\n     return   networkNames , accessPoints  def   rssiPublisher (): \n     # Single call to the parameter server \n     rosParams   =   rospy . get_param ( rssi ) \n         # { \n         #      accessPoints : { \n         #          ap1 : { \n         #              signalAttenuation : 3,  \n         #              location : { \n         #                  y : 7,  \n         #                  x : 1 \n         #             },  \n         #              reference : { \n         #                  distance : 5,  \n         #                  signal : 60 \n         #             },  \n         #              name :  \n         #              dd-wrt \n         #         },  \n         #          ap2 : { \n         #              name :  OnePlus3 ,  \n         #              location : { \n         #                  y : 11,  \n         #                  x : 3 \n         #             }, \n         #              reference : { \n         #                  distance : 4,  \n         #                  signal : 40 \n         #             },  \n         #              signalAttenuation : 3 \n         #         }, \n         #     } \n         #      networkInterface :  wlp1s0 \n         # } \n\n     pub   =   rospy . Publisher ( rssiLocalization_topic ,   MotorArray ,   queue_size = 10 ) \n     # Get parameters from our ROS server \n     networkInterface   =   rosParams [ networkInterface ] \n     ssids , networks   =   getNetworks ( rosParams [ accessPoints ]) \n     # Initialize node \n     rospy . init_node ( rssiPublisher_node ) \n     # Create instance of RSSI module. \n     # This makes our  getAccessPoints  function available to us. \n     rssi   =   RSSI_Scan ( networkInterface ) \n     localizer   =   RSSI_Localizer ( networks ) \n     # This keeps the node running until the script is shut down manually. \n     # node will keep cycling at the frequncy set above. \n     while   not   rospy . is_shutdown ():  \n         # Returns an array of all access-points of interest (if they are in range). \n         # Process takes about 1.5-4 seconds to finish. \n         ap_info   =   rssi . getAPinfo ( networks = ssids ,   sudo = True ) \n         # rospy.loginfo(ap_info) \n         rssi_values   =   [ ap [ signal ]   for   ap   in   ap_info ] \n         rospy . loginfo ( rssi_values ) \n         distances   =   localizer . getDistancesForAllAPs ( rssi_values ) \n         distances   =   [ distance [ distance ]   for   distance   in   distances ] \n         rospy . loginfo ( distances ) \n         position   =   localizer . getNodePosition ( rssi_values ) \n         # if len(ap_info) 2: \n         #     continue \n         # rospy.loginfo(rssi_values) \n         rospy . loginfo ( position ) \n\n         # pub.publish(aps[0][ signal ],aps[1][ signal ],0)  if   __name__   ==   __main__ : \n     try : \n         rssiPublisher () \n     except   rospy . ROSInterruptException : \n         pass", 
            "title": "RSSI Node"
        }, 
        {
            "location": "/projectSlackChannel/", 
            "text": "Project Slack Channel\n\n\nFor full documentation visit \nmkdocs.org\n.\n\n\nHelp / Issues\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nSuggestions / Requests\n\n\n1\n2\n3\n4\nmkdocs\n.\nyml\n    \n#\n \nThe\n \nconfiguration\n \nfile\n.\n\n\ndocs\n/\n\n    \nindex\n.\nmd\n  \n#\n \nThe\n \ndocumentation\n \nhomepage\n.\n\n    \n...\n       \n#\n \nOther\n \nmarkdown\n \npages\n,\n \nimages\n \nand\n \nother\n \nfiles\n.", 
            "title": "Project Slack Channel"
        }, 
        {
            "location": "/projectSlackChannel/#project-slack-channel", 
            "text": "For full documentation visit  mkdocs.org .", 
            "title": "Project Slack Channel"
        }, 
        {
            "location": "/projectSlackChannel/#help-issues", 
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.", 
            "title": "Help / Issues"
        }, 
        {
            "location": "/projectSlackChannel/#suggestions-requests", 
            "text": "1\n2\n3\n4 mkdocs . yml      #   The   configuration   file .  docs / \n     index . md    #   The   documentation   homepage . \n     ...         #   Other   markdown   pages ,   images   and   other   files .", 
            "title": "Suggestions / Requests"
        }
    ]
}